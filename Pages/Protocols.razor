@page "/protocols"
@using System.Threading.Tasks
@using System.Text.Json
@inject WebSocketService WebSocketService
@using MyBlazorPwa
@inject Blazored.LocalStorage.ILocalStorageService localStorage

@inject IJSRuntime JSRuntime
<h1>Protocol Monitor</h1>
<h2>Tempo restante para a próxima atualização: @timeRemaining.Minutes:@timeRemaining.Seconds</h2>

@if (isLoading)
{
  <div class="fade-in">
    <div class="loader"></div> <span>Adicionando novo protocolo</span>
  </div>
}
@if(isLoading = false){
  <div class="fade-out">
    <div class="loader"></div>
  </div>
}
@if (isConnecting)
{
  <div class="fade-in">
    <div class="loader"></div> <span>Estabelecendo conexão com o back-end local</span>
  </div>
}
else if (isConnected && !hasConnectionMessageDisappeared)
{
  <div class="fade-out"> <span>Conexão estabelecida!</span>
  </div>
}

<div>
  <form id="textForm" @onsubmit="RequestProtocolData">
    <input type="text" id="userInput" @bind="userInput" name="userInput" placeholder="Número do protocolo">
    <button type="submit">Pesquisar Protocolo</button> 
  </form>
  <DropDown  OnSectorChange="BySectorRequestMiniProtocolData"/> 
</div>

<button @onclick="ShowConfigModal">Configurações</button>

@if (isConfigModalVisible)
{
    <div class="modal">
        <div class="modal-content">
            <span class="close-button" @onclick="HideConfigModal">&times;</span>
            <h3>Configurações de Acompanhamento</h3>
            
            <label for="expectativa">Expectativa de tempo para movimentação (em dias):</label>
            <input type="number" id="expectativa" @bind="colorConfig.ConfigExpectativaMovimentacao" />

            <label for="verde">Limite para verde (dias):</label>
            <input type="number" id="verde" @bind="colorConfig.ConfigVerde" />

            <label for="amarelo">Limite para laranja (dias):</label>
            <input type="number" id="amarelo" @bind="colorConfig.ConfigAmarelo" />

            <label for="vermelho">Limite para vermelho (dias):</label>
            <input type="number" id="vermelho" @bind="colorConfig.ConfigVermelho" />

            <button @onclick="SaveConfigurations">Salvar</button>
        </div>
    </div>
}

@if (protocols.Any()) // Verifica se há protocolos na lista
{
    <div class="fade-in">
      <ProtocolVisualizer protocolsList="@protocols"/>
    </div>
}

@if (miniprotocols.Any()) // Verifica se há protocolos na lista
{
  <div class="fade-in">
    <MiniProtocolGrid miniProtocolsList="@miniprotocols" Config="colorConfig" />
  </div>
}

<!--
expectedMoveDate =@expectativaMovimentacao currentDate =@dataAtual 
@if (miniprotocols.Any()) // Verifica se há protocolos na lista
{
  <div class="fade-in">
    <MiniProtocolVisualizer miniprotocolsList="@miniprotocols" expectedMoveDate = "@expectativaMovimentacao" currentDate = "@dataAtual" />
  </div>
}
-->

@if (ProtocolRequestStatus != true)
{
  <h4>Ocorreu um erro ao requisitar um novo protocolo</h4>
}
@if (!protocols.Any() && !miniprotocols.Any())
{
  <p>Não há protocolos salvos. Por favor pesquise Novos protocolos</p>
}

@code {
  private DateTime expectativaMovimentacao = DateTime.Now.AddDays(3);
  private DateTime dataAtual = DateTime.Now;
  private bool ProtocolRequestStatus = true;
  private string? userInput;
  private bool isLoading = false; // Começar sem loading
  private bool isConnecting = true;
  private bool isConnected = false; // Estado para conexão
  private bool hasConnectionMessageDisappeared = false; // Estado para controle de mensagem
  private string? receivedMessage;
  private ProtocolData protocolInstance = new ProtocolData();
  private List<ProtocolData> protocols = new List<ProtocolData>();
  private MiniProtocolData miniProtocolInstance = new MiniProtocolData();
  private List<MiniProtocolData> miniprotocols = new List<MiniProtocolData>();
  private TimeSpan timeRemaining = TimeSpan.FromMinutes(0.1); // Timer inicial de 5 minutos
  private string? selectedSector; // Setor selecionado
 private bool isConfigModalVisible = false;
  
  // Nova instância da classe ByTimeColorConfig
  private ByTimeColorConfig colorConfig = new ByTimeColorConfig();
  
  private System.Timers.Timer timer; // Timer do sistema

  private async Task StartTimer()
{
    while (timeRemaining.TotalSeconds > 0)
    {
      await Task.Delay(1000); // Espera 1 segundo
      timeRemaining = timeRemaining.Subtract(TimeSpan.FromSeconds(1));
      StateHasChanged();
    }

    // Quando o tempo acabar, realize a pesquisa de mini protocolos
    await BySectorRequestMiniProtocolData(selectedSector);
    
    // Reinicie o timer para 5 minutos
    timeRemaining = TimeSpan.FromMinutes(0.5);
    StateHasChanged();
}

  private void OnSectorChange(string sector)
{
    selectedSector = sector; // Armazena o setor selecionado
}
  
  private void ShowConfigModal()
  {
      isConfigModalVisible = true;
      StateHasChanged();
  }

  private void HideConfigModal()
  {
      isConfigModalVisible = false;
      StateHasChanged();
  }

  private async void SaveConfigurations()
  {
    // Salve a instância da classe ByTimeColorConfig no Local Storage
    await localStorage.SetItemAsync("colorConfig", colorConfig);

    // Atualize a expectativa de movimentação com base na configuração salva
    expectativaMovimentacao = DateTime.Now.AddDays(colorConfig.ConfigExpectativaMovimentacao ?? 0);
    HideConfigModal();
  }

  private async Task ConnectWebSocket() {
    await WebSocketService.ConnectAsync();
  }

  private async Task RequestProtocolData() {
  ProtocolRequestStatus = true;
  isLoading = true;
  receivedMessage = null;
  StateHasChanged();

  await WebSocketService.SendAsync("ProtocolScrape " + userInput);
  receivedMessage = await WebSocketService.ReceiveAsync();

  if (!string.IsNullOrEmpty(receivedMessage)) {
    Console.WriteLine("Dados de protocolo enviado - Mensagem Recebida do Back-end Node");

    // Crie uma nova instância de ProtocolData para cada novo protocolo recebido
    var newProtocolInstance = new ProtocolData();
    ProtocolLoader.PD_FromJson(receivedMessage, ref newProtocolInstance);

    // Verifique se o protocolo já existe antes de adicionar
    if (!protocols.Any(p => p.Header.Numero == newProtocolInstance.Header.Numero)) {
      protocols.Add(newProtocolInstance);
      await localStorage.SetItemAsync("protocols", protocols); // Salve a lista no Local Storage
    }
  }

  isLoading = false; // Certifique-se de que o estado de carregamento seja encerrado
  StateHasChanged();
}

  private async Task BySectorRequestMiniProtocolData(string sector) {
  ProtocolRequestStatus = true;
  isLoading = true;
  receivedMessage = null;
  StateHasChanged();

  await WebSocketService.SendAsync("BySectorMiniProtocolsScrape " + sector);
  receivedMessage = await WebSocketService.ReceiveAsync();

  if (!string.IsNullOrEmpty(receivedMessage)) {
    Console.WriteLine(" Resultado da busca por miniprotocolos, enviada - Mensagem Recebida do Back-end Node");

    // Crie uma nova instância de ProtocolData para cada novo protocolo recebido
    var newMiniProtocolList = new List<MiniProtocolData>();
    ProtocolLoader.MiniPD_FromJson(receivedMessage, ref newMiniProtocolList);

    // Verifique se o protocolo já existe antes de adicionar
    foreach(MiniProtocolData miniProtocol in newMiniProtocolList){
      if (!miniprotocols.Any(p => p.Numero == miniProtocol.Numero)) {
      miniprotocols.Add(miniProtocol);
      // Salve a lista no Local Storage
      }
    }
    await localStorage.SetItemAsync("miniprotocols", miniprotocols); 
  }

  isLoading = false; // Certifique-se de que o estado de carregamento seja encerrado
  StateHasChanged();
}

  private async Task TryConnectWebSocket() {
    while (!isConnected) {
      isConnecting = true; // Mostrar loader
      StateHasChanged();
      try {
        await ConnectWebSocket();
        isConnected = true; // Definir como conectado
        isConnecting = false; // Remover loader
        await ShowConnectionMessage(); // Mostrar a mensagem de conexão
      } catch (Exception) {
        // Se falhar, espere um pouco antes de tentar novamente
        await Task.Delay(2000);
      }
    }
  }

  private async Task ShowConnectionMessage() {
    await Task.Delay(500); // Esperar um pouco antes de mostrar a mensagem
    hasConnectionMessageDisappeared = false;
    StateHasChanged();
    await Task.Delay(2000); // Tempo da mensagem de conexão
    hasConnectionMessageDisappeared = true;
    StateHasChanged();
  }

  protected override async Task OnInitializedAsync() {
    var savedProtocols = await localStorage.GetItemAsync<List<ProtocolData>>("protocols");
    var savedMiniProtocols = await localStorage.GetItemAsync<List<MiniProtocolData>>("miniprotocols");
    if (savedMiniProtocols != null) {
      miniprotocols = savedMiniProtocols; // Carregue protocolos salvos
    }
    
    var savedConfig = await localStorage.GetItemAsync<ByTimeColorConfig>("colorConfig");
    if (savedConfig != null)
    {
        colorConfig = savedConfig;
        expectativaMovimentacao = DateTime.Now.AddDays(colorConfig.ConfigExpectativaMovimentacao ?? 0);
    }
    
    // Tentar conectar ao WebSocket automaticamente
    await TryConnectWebSocket();
    
    // Inicie o timer
    //await StartTimer();
    
    
  }
}
