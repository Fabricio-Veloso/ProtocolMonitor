@using MyBlazorPwa
@inject IJSRuntime JSRuntime

<div class="miniprotocol-grid">
    
     @if (protocolsList != null && protocolsList.Any())
    {
        @foreach (var protocol in protocolsList)
        {
            <div class="protocol-card @(GetColorClass(protocol.GetDataUltimoMovimento()))" @onclick="() => ShowProtocolModal(protocol)">
                <div class="content">
                    <p class="description">@protocol.Header.Descricao</p>
                </div>
            </div>
        }
    }
    else
    {
        <p>Nenhum protocolo encontrado.</p>
    }

    <!-- mostra os mini protocolos -->
    @if (miniProtocolsList != null && miniProtocolsList.Any())
    {
        @foreach (var miniProtocol in miniProtocolsList.Where(p => !IsInBlacklist(p.Numero)))
        {
            <div class="miniprotocol-card @(GetColorClass(miniProtocol.DataUltimoMovimento))" @onclick="() => ShowMiniProtocolModal(miniProtocol)">
                <div class="content">
                    <p class="description">@miniProtocol.Descricao</p>
                </div>
            </div>
        }
    }else
    {
        <p>Nenhum Mini-protocolo encontrado.</p>
    }
    
    <!-- Modal do protocolo completo -->
    @if (isProtocolModalVisible && selectedProtocol != null)
    {
        <div class="modal">
            <div class="modal-content">
                <span class="close-button" @onclick="HideProtocolModal">&times;</span>
                <h3>Protocolo: @selectedProtocol.Header?.Numero</h3>
                    <p><strong>Interessado:</strong> @selectedProtocol.Header?.Interessado</p>
                    <p><strong>Solicitante:</strong> @selectedProtocol.Header?.Solicitante</p>
                    <p><strong>Inspetoria:</strong> @selectedProtocol.Header?.Inspetoria</p>
                    <p><strong>Assunto:</strong> @selectedProtocol.Header?.Assunto</p>
                    <p><strong>Origem:</strong> @selectedProtocol.Header?.Origem</p>
                    <p><strong>Situação:</strong> @selectedProtocol.Header?.Situacao</p>
                    <p><strong>Destino:</strong> @selectedProtocol.Header?.Destino</p>
                    <p><strong>Sigiloso:</strong> @selectedProtocol.Header?.Sigiloso?</p>
                    <p><strong>Data de Emissão:</strong> @selectedProtocol.Header?.DataEmissao?</p>
                    <p><strong>Descrição:</strong> @selectedProtocol.Header?.Descricao</p>
                    <button @onclick="() => AddToBlacklist(selectedProtocol.Header.Numero)">Não tenho interesse</button>

                    <h4>Movimentações:</h4>
                    @if (selectedProtocol.Moves != null && selectedProtocol.Moves.Any())
                    {
                        @foreach (var move in selectedProtocol.Moves)
                        {
                          <div class="move-container">
                              <div class="move-card">
                                  <p><strong>Passo:</strong> @move.Passo</p>
                                  <p><strong>Usuário de Origem:</strong> @move.UsuarioOrigem</p>
                                  <p><strong>Usuário de Destino:</strong> @move.UsuarioDestino</p>
                                  <p><strong>Setor de Origem:</strong> @move.SetorOrigem</p>
                                  <p><strong>Setor de Destino:</strong> @move.SetorDestino</p>
                                  <p><strong>Descrição:</strong> @move.Descricao</p>
                                  <p><strong>Data:</strong> @move.Data?</p>
                                  <p><strong>Hora:</strong> @move.Hora?</p>
                                  <p><strong>Sigiloso:</strong> @move.Sigiloso?</p>
                              </div>
                              @if (move != selectedProtocol.Moves.Last())
                              {
                                  <div class="move-separator"></div>
                              }
                          </div>
                        }
                    }
                    else
                    {
                        <p>Nenhuma movimentação encontrada.</p>
                    }
            </div>
        </div>
    }

    @if (isMiniProtocolModalVisible && selectedMiniProtocol != null)
    {
        <div class="modal">
            <div class="modal-content">
                <span class="close-button" @onclick="HideMiniProtocolModal">&times;</span>
                <h3>@selectedMiniProtocol.Assunto</h3>
                <p><strong>Número:</strong> @selectedMiniProtocol.Numero</p>
                <p><strong>Descrição:</strong> @selectedMiniProtocol.Descricao</p>
                <p><strong>Localização Atual:</strong> @selectedMiniProtocol.LocalizacaoAtual</p>
                <p><strong>Último Movimento:</strong> @selectedMiniProtocol.DataUltimoMovimento @selectedMiniProtocol.HoraUltimoMovimento</p>
                <button @onclick="() => AddToBlacklist(selectedMiniProtocol.Numero)">Não tenho interesse</button>
            </div>
        </div>
    }
    
</div>

@code {
    [Parameter]
    public List<MiniProtocolData> miniProtocolsList { get; set; } = new List<MiniProtocolData>();

    [Parameter]
    public List<ProtocolData> protocolsList { get; set; } = new List<ProtocolData>();

     [Parameter]
    public ByTimeColorConfig Config { get; set; }
    
    /*MODAL VARIABLES*/
    private bool isProtocolModalVisible = false;
    private bool isMiniProtocolModalVisible = false;
    private MiniProtocolData? selectedMiniProtocol = null;
    private ProtocolData? selectedProtocol = null;

    // Lista negra para armazenar números de protocolos
    private HashSet<string> blacklist = new HashSet<string>();

  protected override async Task OnInitializedAsync()
  {
      await LoadBlacklistFromLocalStorage();
  }

  private async Task SaveBlacklistToLocalStorage()
{
  var json = JsonConvert.SerializeObject(blacklist); // Serializa a blacklist
  await JSRuntime.InvokeVoidAsync("localStorage.setItem", "blacklist", json); // Armazena no localStorage
}

  private async Task LoadBlacklistFromLocalStorage()
{
    var json = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "blacklist"); // Obtém o JSON do localStorage
    if (!string.IsNullOrEmpty(json))
    {
        blacklist = JsonConvert.DeserializeObject<HashSet<string>>(json); // Desserializa a blacklist
    }
}

  private void ShowProtocolModal(ProtocolData protocol)
    {
        selectedProtocol = protocol;
        isProtocolModalVisible = true;
        StateHasChanged(); 
    }

  private void HideProtocolModal()
    {
        isMiniProtocolModalVisible = false;
        selectedProtocol = null;
    }
    
  private void ShowMiniProtocolModal(MiniProtocolData miniProtocol)
    {
        selectedMiniProtocol = miniProtocol;
        isMiniProtocolModalVisible = true;
        StateHasChanged();
    }
    
  private void HideMiniProtocolModal()
    {
        isMiniProtocolModalVisible = false;
        selectedMiniProtocol = null;
    }
   
  private async Task AddToBlacklist(string numero)
  {
      blacklist.Add(numero); // Adiciona o número à lista negra
      await SaveBlacklistToLocalStorage(); // Salva a blacklist no localStorage
      HideProtocolModal();
      HideMiniProtocolModal();// Oculta o modal após adicionar
      StateHasChanged(); // Atualiza a interface
  }

  private bool IsInBlacklist(string numero)
    {
        return blacklist.Contains(numero); // Verifica se o número está na lista negra
    }

  List<DateTime> feriados = new List<DateTime>
{
    new DateTime(2024, 1, 1),  // Ano Novo
    new DateTime(2024, 2, 10), // Carnaval (sábado)
    new DateTime(2024, 2, 12), // Carnaval (segunda-feira)
    new DateTime(2024, 2, 13), // Carnaval (terça-feira)
    new DateTime(2024, 2, 14), // Quarta-feira de Cinzas (quarta-feira)
    new DateTime(2024, 3, 29), // Sexta-feira Santa
    new DateTime(2024, 3, 31), // Páscoa (domingo)
    new DateTime(2024, 4, 21), // Tiradentes
    new DateTime(2024, 5, 1),  // Dia do Trabalho
    new DateTime(2024, 5, 30), // Corpus Christi
    new DateTime(2024, 9, 7),  // Independência do Brasil
    new DateTime(2024, 10, 12),// Nossa Senhora Aparecida / Dia das Crianças
    new DateTime(2024, 11, 2), // Finados
    new DateTime(2024, 11, 15),// Proclamação da República
    new DateTime(2024, 12, 25) // Natal
};
  
  public int GetDiasUteis(DateTime startDate, DateTime endDate, List<DateTime> feriados)
{
    int diasUteis = 0;

    for (var date = startDate; date <= endDate; date = date.AddDays(1))
    {
        // Ignora finais de semana (sábado e domingo)
        if (date.DayOfWeek != DayOfWeek.Saturday && date.DayOfWeek != DayOfWeek.Sunday)
        {
            // Ignora feriados
            if (!feriados.Contains(date))
            {
                diasUteis++;
            }
        }
    }

    return diasUteis;
}

  private string GetColorClass(string dataUltimoMovimento)
{
    if (DateTime.TryParse(dataUltimoMovimento, out var lastMoveDate))
    {
        // Data atual
        var dataAtual = DateTime.Now;
        
        // Expectativa de movimentação
        var expectativaMovimentacao = Config.ConfigExpectativaMovimentacao ?? 0;

        // Lista de feriados 2024
        List<DateTime> feriados = new List<DateTime>
        {
            new DateTime(2024, 1, 1), new DateTime(2024, 2, 12), new DateTime(2024, 2, 13), 
            new DateTime(2024, 2, 14), new DateTime(2024, 3, 29), new DateTime(2024, 4, 21), 
            new DateTime(2024, 5, 1), new DateTime(2024, 5, 30), new DateTime(2024, 9, 7), 
            new DateTime(2024, 10, 12), new DateTime(2024, 11, 2), new DateTime(2024, 11, 15), 
            new DateTime(2024, 12, 25)
        };

        // Calcula a diferença em dias úteis
        var diasUteis = GetDiasUteis(lastMoveDate, dataAtual, feriados);

        // Verifica se a diferença está dentro da expectativa
        if (diasUteis <= expectativaMovimentacao)
        {
            return Config.ColorVerde; // Dentro do prazo, retorna verde
        }
        else
        {
            // Diferença acima da expectativa, inicia o cálculo
            var sobra = diasUteis - expectativaMovimentacao;

            if (sobra > 0)
            {
                // Subtrai a configuração amarelo
                sobra -= Config.ConfigAmarelo ?? 0;

                if (sobra > 0)
                {
                    // Subtrai a configuração vermelho
                    sobra -= Config.ConfigVermelho ?? 0;

                    if (sobra > 0)
                    {
                        return Config.ColorPreto; // Retorna preto se ainda sobrar
                    }

                    return Config.ColorVermelho; // Retorna vermelho se sobrar
                }

                return Config.ColorAmarelo; // Retorna amarelo se sobrar
            }
        }
    }

    return string.Empty; // Retorna vazio se a data não for válida
}
}


