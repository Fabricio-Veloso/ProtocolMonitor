@using MyBlazorPwa
@inject IJSRuntime JSRuntime
@using MudBlazor


<div>

  
  <div>
    <MudButton OnClick="() => OpenModal(protocolsList)">Abrir Gráfico</MudButton>

    <MudDialog @bind-Open="ischartModalVisible">
        <DialogContent>
            <MudDonutChart Data="@chartData" Label="Setor" Value="AverageHours" />
        </DialogContent>
        <DialogActions>
            <MudButton OnClick="() => ischartModalVisible = false">Fechar</MudButton>
        </DialogActions>
    </MudDialog>
    </div>
  
  <div> 
      
      @foreach (var phase in phases)
      {
         var displayPhase = phase.Replace("PROCESSO DE AQUISIÇÕES DE BENS E SERVIÇOS - PABS - CREA-PE - 0", "").Trim();
          <button class="button"
                  style="background-color: @GetPhaseColor(displayPhase); @GetActiveButtonStyle(phase)"
                  @onclick="() => SetActivePhase(phase)">
              Filtrar por @displayPhase
          </button>
      }
      
      <button class="button" 
              style="@GetActiveButtonStyle("ByDate")"
              @onclick="() => FilterByDate()">
          Filtrar por Data
      </button>
      
      <button class="button" 
              style="@GetActiveButtonStyle("Adopted")"
              @onclick="() => ShowAdoptedProtocols()">
          Mostrar Protocolos sob sua responsabilidade
      </button>
      
      <button class="button" 
              style="@GetActiveButtonStyle("All")"
              @onclick="() => ShowAllProtocols()">
          Mostrar Todos os Protocolos
      </button>
      
      <form id="textForm" style="margin-bottom: 20px">
        <input type="text" id="userInput" @bind="searchTerm" @oninput="FilterByText" name="userInput" placeholder="Número do protocolo ou descrição" class="input-field">
      </form>
    </div> 
    
    
    
    
  <div class="miniprotocol-grid">
    
    
    @if (filteredBySearch != null && filteredBySearch.Any())
  {
      foreach (var protocol in filteredBySearch)
      {
          <div class="protocol-card @(GetColorClass(protocol.GetDataUltimoMovimento()))"
               title="Descrição: @protocol.Header.Descricao | Atualmente em: @protocol.GetSetorUltimoMovimento()"
               @onclick="() => ShowProtocolModal(protocol)">
               
              <div class="content">
                  <p class="description">@TruncateDescription(protocol.Header.Descricao)</p>
              </div>
          </div>
      }
  }
  
    
    @if (currentFilter == FilterMode.ByDate && filteredByDate != null && filteredByDate.Any())
    {
        @foreach (var protocol in filteredByDate)
        {
            <div class="protocol-card @(GetColorClass(protocol.GetDataUltimoMovimento()))"
                 title="Descrição: @protocol.Header.Descricao | Atualmente em: @protocol.GetSetorUltimoMovimento()"
                 @onclick="() => ShowProtocolModal(protocol)">
                 <div class="phase-label @(GetPhaseClass(protocol.Header.Assunto))"></div>
                <div class="content">
                    <p class="description">@TruncateDescription(protocol.Header.Descricao)</p>
                </div>
            </div>
        }
    }
    
    @if (currentFilter == FilterMode.ByPhase && (protocolsWithResponsable?.Any() == true || protocolsWithoutResponsable?.Any() == true))
    {
        @if (groupedProtocols != null && groupedProtocols.Any())
      {
          foreach (var group in groupedProtocols)
          {
              <div class="responsavel-group">
                  <div class=".responsavel-group h3">
                    <h3>@GetFirstTwoWords(group.Key)</h3>
        
                  @if (group.Any())
                  {
                      foreach (var protocol in group)
                      {
                          <div class="protocol-card @(GetColorClass(protocol.GetDataUltimoMovimento()))"
                               title="Descrição: @protocol.Header.Descricao | Atualmente em: @protocol.GetSetorUltimoMovimento()"
                               @onclick="() => ShowProtocolModal(protocol)">
                              <div class="content">
                                  <p class="description">@TruncateDescription(protocol.Header.Descricao)</p>
                              </div>
                          </div>
                      }
                  }
                  else
                  {
                    <p>Sem protocolos disponíveis para este responsável.</p>
                  }
              </div>
            </div>
          }
      }
      
      @if (protocolsWithoutResponsable != null && protocolsWithoutResponsable.Any())
      {
          <div class="sem-responsavel-group">
              @foreach (var protocol in protocolsWithoutResponsable)
              {
                  <div class="protocol-card @(GetColorClass(protocol.GetDataUltimoMovimento()))"
                       title="Descrição: @protocol.Header.Descricao | Atualmente em: @protocol.GetSetorUltimoMovimento()"
                       @onclick="() => ShowProtocolModal(protocol)">
                      <div class="content">
                          <p class="description">@TruncateDescription(protocol.Header.Descricao)</p>
                      </div>
                  </div>
              }
          </div>
      }
     
  }
  
    
      
    
    @if (currentFilter == FilterMode.Adopted && adoptedProtocols != null && adoptedProtocols.Any())
    {
        foreach (var protocol in adoptedProtocols)
        {
            <div class="protocol-card @(GetColorClass(protocol.GetDataUltimoMovimento()))"
                 title="Descrição: @protocol.Header.Descricao | Atualmente em: @protocol.GetSetorUltimoMovimento()"
                 @onclick="() => ShowProtocolModal(protocol)">
                 <div class="phase-label @(GetPhaseClass(protocol.Header.Assunto))"></div>
                <div class="content">
                    <p class="description">@TruncateDescription(protocol.Header.Descricao)</p>
                </div>
            </div>
        }
    }
   
    @if( currentFilter == FilterMode.None && protocolsList != null && protocolsList.Any())
    {
      foreach (var protocol in protocolsList)
      {
        <div class="protocol-card @(GetColorClass(protocol.GetDataUltimoMovimento()))"
           title="Descrição: @protocol.Header.Descricao | Atualmente em: @protocol.GetSetorUltimoMovimento()"
           @onclick="() => ShowProtocolModal(protocol)">
           <div class="phase-label @(GetPhaseClass(protocol.Header.Assunto))"></div>
          <div class="content">
              <p class="description">@TruncateDescription(protocol.Header.Descricao)</p>
          </div>
        </div>
      }
    }
    
    @if (miniProtocolsList != null && miniProtocolsList.Any() && currentFilter == FilterMode.None)
  {
      foreach (var miniProtocol in miniProtocolsList.Where(p => !IsInBlacklist(p.Numero)))
      {
          <div class="miniprotocol-card @(GetColorClass(miniProtocol.DataUltimoMovimento))"
               title="Descrição: @miniProtocol.Descricao | Atualmente em: @miniProtocol.LocalizacaoAtual"
               @onclick="() => ShowMiniProtocolModal(miniProtocol)">
              <div class="content">
                  <div class="loader"></div>
                  <p class="description">@TruncateDescription(miniProtocol.Descricao)</p>
              </div>
          </div>
      }
  }
  
    <!-- Modal do protocolo completo -->
    @if (isProtocolModalVisible && selectedProtocol != null)
    {
        <div class="modal">
            <div class="modal-content">
                <span class="close-button" @onclick="HideProtocolModal">&times;</span>
                <h3>Protocolo: @selectedProtocol.Header?.Numero</h3>
                    <p><strong>Interessado:</strong> @selectedProtocol.Header?.Interessado</p>
                    <p><strong>Solicitante:</strong> @selectedProtocol.Header?.Solicitante</p>
                    <p><strong>Inspetoria:</strong> @selectedProtocol.Header?.Inspetoria</p>
                    <p><strong>Assunto:</strong> @selectedProtocol.Header?.Assunto</p>
                    <p><strong>Origem:</strong> @selectedProtocol.Header?.Origem</p>
                    <p><strong>Situação:</strong> @selectedProtocol.Header?.Situacao</p>
                    <p><strong>Destino:</strong> @selectedProtocol.Header?.Destino</p>
                    <p><strong>Sigiloso:</strong> @selectedProtocol.Header?.Sigiloso?</p>
                    <p><strong>Data de Emissão:</strong> @selectedProtocol.Header?.DataEmissao?</p>
                    <p><strong>Descrição:</strong> @selectedProtocol.Header?.Descricao</p>
                    <div>
                      <button class="button"  @onclick="() => AddToBlacklist(selectedProtocol.Header.Numero)">Apagar protocolo</button>
                      @if (IsAdopted(selectedProtocol.Header.Numero))
                      {
                          <button class="button" @onclick="() => RemoveFromAdoptedProtocols(selectedProtocol.Header.Numero)">Retirar da lista de protocolos sob sua responsabilidade</button>
                      }
                      else
                      {
                          <button class="button" @onclick="() => AddToAdoptedProtocols(selectedProtocol.Header.Numero)">Adotar</button>
                      }
                    </div>
                    <h4>Movimentações:</h4>
                    @if (selectedProtocol.Moves != null && selectedProtocol.Moves.Any())
                    {
                        @foreach (var move in selectedProtocol.Moves)
                        {
                          <div class="move-container">
                              <div class="move-card">
                                  <p><strong>Passo:</strong> @move.Passo</p>
                                  <p><strong>Usuário de Origem:</strong> @move.UsuarioOrigem</p>
                                  <p><strong>Usuário de Destino:</strong> @move.UsuarioDestino</p>
                                  <p><strong>Setor de Origem:</strong> @move.SetorOrigem</p>
                                  <p><strong>Setor de Destino:</strong> @move.SetorDestino</p>
                                  <p><strong>Descrição:</strong> @move.Descricao</p>
                                  <p><strong>Data:</strong> @move.Data?</p>
                                  <p><strong>Hora:</strong> @move.Hora?</p>
                                  <p><strong>Sigiloso:</strong> @move.Sigiloso?</p>
                              </div>
                              @if (move != selectedProtocol.Moves.Last())
                              {
                                  <div class="move-separator"></div>
                              }
                          </div>
                        }
                    }
                    else
                    {
                        <p>Nenhuma movimentação encontrada.</p>
                    }
            </div>
        </div>
    }
  
    @if (isMiniProtocolModalVisible && selectedMiniProtocol != null)
      {
          <div class="modal">
              <div class="modal-content">
                  <span class="close-button" @onclick="HideMiniProtocolModal">&times;</span>
                  <h3>@selectedMiniProtocol.Assunto</h3>
                  <p><strong>Número:</strong> @selectedMiniProtocol.Numero</p>
                  <p><strong>Descrição:</strong> @selectedMiniProtocol.Descricao</p>
                  <p><strong>Localização Atual:</strong> @selectedMiniProtocol.LocalizacaoAtual</p>
                  <p><strong>Último Movimento:</strong> @selectedMiniProtocol.DataUltimoMovimento @selectedMiniProtocol.HoraUltimoMovimento</p>
                  <button class="button" @onclick="() => AddToBlacklist(selectedMiniProtocol.Numero)">Não tenho interesse</button>
              </div>
          </div>
      }
      
   



  </div>

</div>


@code {
    [Parameter]
    public List<MiniProtocolData> miniProtocolsList { get; set; } = new List<MiniProtocolData>();

    [Parameter]
    public List<ProtocolData> protocolsList { get; set; } = new List<ProtocolData>();

    [Parameter]
    public ByTimeColorConfig Config { get; set; }
    
    [Parameter]
    public string sector { get; set; }
    
    

    /*MODAL VARIABLES*/
    private bool isProtocolModalVisible = false;
    private bool isMiniProtocolModalVisible = false;
    private MiniProtocolData? selectedMiniProtocol = null;
    private ProtocolData? selectedProtocol = null;

    // Lista negra para armazenar números de protocolos apagados
    private HashSet<string> blacklist = new HashSet<string>();
    
    /*GRAFIC VARIABLES AND FUNCTIONS*/
    public class ChartData
    {
        public string? Setor { get; set; }
        public double AverageHours { get; set; }
    }
    private List<ChartData> chartData = new List<ChartData>();

    public void PrepareChartData(List<ProtocolData> protocolos)
    {
        var mediaHorasPorSetor = CalcularMediaHorasPorSetor(protocolos);
        chartData = mediaHorasPorSetor.Select(kvp => new ChartData
        {
            Setor = kvp.Key,
            AverageHours = kvp.Value
        }).ToList();
    }
    
    
    private List<string> setores = new List<string>();
    private List<double> mediasHoras = new List<double>();
    private bool ischartModalVisible = false;
    
    void OpenModal(List<ProtocolData> protocols)
    {
        if (protocols == null || !protocols.Any())
        {
            
            return;
        }
         PrepareChartData(protocols);
        ischartModalVisible = true;
      }
        


    // Função que será chamada ao clicar no botão para gerar o gráfico
   
    public class SectorTimeData
{
    public string Setor { get; set; }
    public double TotalHours { get; set; }
    public int Occurrences { get; set; }

    public double AverageHours()
    {
        return Occurrences > 0 ? TotalHours / Occurrences : 0;
    }
}

    // Função para calcular a média de horas por setor  
    public Dictionary<string, double> CalcularMediaHorasPorSetor(List<ProtocolData> protocolos)
{
    var setorTimeData = new Dictionary<string, SectorTimeData>();

    foreach (var protocolo in protocolos)
    {
        var movimentos = protocolo.Moves;

        for (int i = 1; i < movimentos.Count; i++) // Começa do segundo movimento
        {
            var movimentoAnterior = movimentos[i - 1];
            var movimentoAtual = movimentos[i];

            if (!string.IsNullOrEmpty(movimentoAnterior.Data) && !string.IsNullOrEmpty(movimentoAtual.Data))
            {
                DateTime dataAnterior = DateTime.Parse(movimentoAnterior.Data);
                DateTime dataAtual = DateTime.Parse(movimentoAtual.Data);

                TimeSpan diff = dataAtual - dataAnterior;
                string setor = movimentoAnterior.SetorDestino ?? "Sem setor";

                if (!setorTimeData.ContainsKey(setor))
                {
                    setorTimeData[setor] = new SectorTimeData { Setor = setor, TotalHours = 0, Occurrences = 0 };
                }

                setorTimeData[setor].TotalHours += diff.TotalHours;
                setorTimeData[setor].Occurrences++;
            }
        }
    }

    // Retorna a média de horas por setor
    return setorTimeData.ToDictionary(data => data.Key, data => data.Value.AverageHours());
}
    /*GRAFIC VARIABLES AND FUNCTIONS*/
    
    /*FILTERS VARIABLES*/
    
    private DateTime? selectedDate; // Para filtro por data
    private string? selectedPhase; // Para filtro por fase
    private List<string> phases = new List<string>
    {
        "01 - SOLICITAÇÃO DE CONTRATAÇÃO",
        "02 - PLANEJAMENTO DE CONTRATAÇÃO",
        "03 - CONTRATAÇÃO DIRETA",
        "04 - LICITAÇÃO",
        "05 - EXECUÇÃO",
        "06 - ADITIVO DE CONTRATO"
    };
    private string activePhase = string.Empty;
    
    private enum FilterMode
    {
      None,
      ByDate,
      ByPhase,
      Adopted,
      ByTextSeach
    }

    private FilterMode currentFilter = FilterMode.None;
    private IEnumerable<ProtocolData>? filteredByDate;
    private Dictionary<string, IEnumerable<ProtocolData>> filteredByPhase = new Dictionary<string, IEnumerable<ProtocolData>>();
    private IEnumerable<ProtocolData>? adoptedProtocols;
    private HashSet<string> adoptedProtocolsList = new HashSet<string>();
    private string activeButton = string.Empty; 
    private string searchTerm = string.Empty; // Para armazenar o termo de busca
    private IEnumerable<IGrouping<string, ProtocolData>>? groupedProtocols; // Agrupado por responsável
    private IEnumerable<ProtocolData>? protocolsWithResponsable; // Protocolos com responsável
    private IEnumerable<ProtocolData>? protocolsWithoutResponsable; // Protocolos sem responsável
   
     /*FILTERS VARIABLES*/
    
    
    /*FILTERS FUNCTIONS*/
    
    private IEnumerable<ProtocolData>? filteredBySearch; // Para armazenar os protocolos filtrados por texto
    
    private void FilterByText(ChangeEventArgs e)
    {
        currentFilter = FilterMode.ByTextSeach;
        searchTerm = e.Value?.ToString() ?? string.Empty; // Atualiza o termo de busca
        
        if (!string.IsNullOrWhiteSpace(searchTerm))
        {
            filteredBySearch = protocolsList
                .Where(p => p.Header.Descricao != null && 
                            p.Header.Descricao.Contains(searchTerm, StringComparison.OrdinalIgnoreCase)) // Filtro por descrição
                .ToList();
        }
        else
        {
            filteredBySearch = null; // Mostra todos se o campo estiver vazio
        }
        
        StateHasChanged(); // Atualiza a interface para refletir o novo filtro
    }
    
    private async Task AddToAdoptedProtocols(string numero)
    {
        if (!adoptedProtocolsList.Contains(numero))
        {
            adoptedProtocolsList.Add(numero); // Adiciona o protocolo à lista
            await SaveAdoptedProtocolsToLocalStorage(); // Salva no LocalStorage
            Console.WriteLine($"Protocolo {numero} foi adotado com sucesso!");
            StateHasChanged();
        }
        else
        {
            Console.WriteLine($"Protocolo {numero} já foi adotado.");
        }
    }
    
    private async Task SaveAdoptedProtocolsToLocalStorage()
    {
        var json = JsonConvert.SerializeObject(adoptedProtocolsList); // Serializa a lista de adotados
        await JSRuntime.InvokeVoidAsync("localStorage.setItem", "adoptedProtocols", json); // Armazena no LocalStorage
    }
    
    private async Task RemoveFromAdoptedProtocols(string numero)
    {
      if (adoptedProtocolsList.Contains(numero))
      {
        adoptedProtocolsList.Remove(numero); // Remove o protocolo da lista
        await SaveAdoptedProtocolsToLocalStorage(); // Atualiza o LocalStorage
        Console.WriteLine($"Você retirou o protocolo de número {numero} de sua lista de responsabilidades");
        HideProtocolModal();
        ShowAdoptedProtocols();
        StateHasChanged();
      }
      else
      {
        Console.WriteLine($"Protocolo {numero} não está na lista de responsabilidade.");
      }
    }
    
    private async Task LoadAdoptedProtocolsFromLocalStorage()
    {
        var json = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "adoptedProtocols"); // Obtém o JSON do LocalStorage
        if (!string.IsNullOrEmpty(json))
        {
            adoptedProtocolsList = JsonConvert.DeserializeObject<HashSet<string>>(json); // Desserializa a lista de adotados
        }
    }
    
    private bool       IsAdopted(string numero)
    {
        return adoptedProtocolsList.Contains(numero);
    }
    
    private void       FilterByDate()
    {
        currentFilter = FilterMode.ByDate;
        filteredByDate = protocolsList
            .OrderBy(p => DateTime.Parse(p.GetDataUltimoMovimento()).Date)
            .ToList();
        activeButton = "ByDate"; // Atualiza o botão ativo
        StateHasChanged(); // Atualiza a interface
    }

    private void       SetActivePhase(string phase)
    {
        activePhase = phase; // Define a fase ativa
        FilterByPhase(phase); // Filtra pela fase selecionada
        activeButton = phase; // Atualiza o botão ativo
        StateHasChanged(); // Atualiza a interface
    }
    
    private void FilterByPhase(string selectedPhase)
    {
        currentFilter = FilterMode.ByPhase;
    
        var protocolsInPhase = protocolsList
            .Where(p => p.Header.Assunto == selectedPhase)
            .ToList();
    
        // Separar os protocolos com e sem responsável
        groupedProtocols = protocolsInPhase
            .Where(p => !string.IsNullOrEmpty(p.Responsavel) && p.Responsavel != "Sem responsavel")
            .GroupBy(p => p.Responsavel)
            .ToList();
    
        protocolsWithoutResponsable = protocolsInPhase
            .Where(p => string.IsNullOrEmpty(p.Responsavel) || p.Responsavel == "Sem responsavel")
            .ToList();
    
        StateHasChanged(); // Atualiza a interface
    }
    
    private string     GetActiveButtonStyle(string buttonName)
    {
        // Se o botão for o ativo, aplica o estilo extra
        if (activeButton == buttonName)
        {
            return "border: 3px solid #ff0000; transform: scale(1.1);"; // Borda vermelha e leve aumento de tamanho
        }
        return string.Empty; // Sem alteração para os botões inativos
    }
    
    private string     GetPhaseColor(string displayPhase)
    {
      return displayPhase switch
      {
        "01 - SOLICITAÇÃO DE CONTRATAÇÃO" => "#ff9306", // Cor para Solicitação
        "02 - PLANEJAMENTO DE CONTRATAÇÃO" => "#0014c4", // Cor para Planejamento
        "03 - CONTRATAÇÃO DIRETA" => "#680091", // Cor para Contratação
        "04 - LICITAÇÃO" => "#dd009b", // Cor para Licitação
        "05 - EXECUÇÃO" => "#818181", // Cor para Execução
        "06 - ADITIVO DE CONTRATO" => "#7d9900", // Cor para Aditivo
        _ => "#6c717d" // Cor padrão se não corresponder
      };
    }
    
    private void       ShowAdoptedProtocols()
    {
        currentFilter = FilterMode.Adopted;
        adoptedProtocols = protocolsList
            .Where(p => adoptedProtocolsList.Contains(p.Header.Numero))
            .ToList();
        activeButton = "Adopted"; // Atualiza o botão ativo
        StateHasChanged(); // Atualiza a interface
    }
    
    private void       ShowAllProtocols()
    {
        currentFilter = FilterMode.None;
        filteredByDate = null;
        filteredByPhase.Clear();
        adoptedProtocols = null;
        activeButton = "All"; // Atualiza o botão ativo
        StateHasChanged(); // Atualiza a interface
    }
    
    public string      GetPhaseClass(string assunto)
    {
      if (phases.Contains(assunto))
      {
        return assunto switch
        {
          "01 - SOLICITAÇÃO DE CONTRATAÇÃO" => "phase-solicitacao",
          "02 - PLANEJAMENTO DE CONTRATAÇÃO" => "phase-planejamento",
          "03 - CONTRATAÇÃO DIRETA" => "phase-contratacao",
          "04 - LICITAÇÃO" => "phase-licitacao",
          "05 - EXECUÇÃO" => "phase-execucao",
          "06 - ADITIVO DE CONTRATO" => "phase-aditivo",
          _ => "phase-default"
        };
      }
      return "phase-default";
    }
  /*FILTERS FUNCTIONS*/
  
  private string GetFirstTwoWords(string input)
    {
        if (string.IsNullOrWhiteSpace(input))
            return string.Empty; // Retorna vazio se a entrada for nula ou vazia

        var words = input.Split(' '); // Divide a string em palavras
        return string.Join(" ", words.Take(2)); // Junta as duas primeiras palavras
    }
  
  private string TruncateDescription(string description)
    {
        if (description.Length > 40)
        {
            return description.Substring(0, 40) + "..."; // Limita a 40 caracteres e adiciona "..."
        }
        return description;
    }


  /*MODAL FUNCTIONS*/
  private void ShowProtocolModal(ProtocolData protocol)
    {
        selectedProtocol = protocol;
        isProtocolModalVisible = true;
        StateHasChanged(); 
    }

  private void HideProtocolModal()
    {
        isMiniProtocolModalVisible = false;
        selectedProtocol = null;
    }
    
  private void ShowMiniProtocolModal(MiniProtocolData miniProtocol)
    {
        selectedMiniProtocol = miniProtocol;
        isMiniProtocolModalVisible = true;
        StateHasChanged();
    }
    
  private void HideMiniProtocolModal()
    {
        isMiniProtocolModalVisible = false;
        selectedMiniProtocol = null;
    }
  /*MODAL FUNCTIONS*/
   
   
   /*Black list FUNCTIONS*/
  private async Task AddToBlacklist(string numero)
  {
    blacklist.Add(numero); // Adiciona o número à lista negra
    await SaveBlacklistToLocalStorage(); // Salva a blacklist no localStorage
    HideProtocolModal();
    HideMiniProtocolModal();// Oculta o modal após adicionar
    StateHasChanged(); // Atualiza a interface
  }

  private bool IsInBlacklist(string numero)
    {
        return blacklist.Contains(numero); // Verifica se o número está na lista negra
    }

  private async Task SaveBlacklistToLocalStorage()
{
  var json = JsonConvert.SerializeObject(blacklist); // Serializa a blacklist
  await JSRuntime.InvokeVoidAsync("localStorage.setItem", "blacklist", json); // Armazena no localStorage
}

  private async Task LoadBlacklistFromLocalStorage()
{
    var json = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "blacklist"); // Obtém o JSON do localStorage
    if (!string.IsNullOrEmpty(json))
    {
        blacklist = JsonConvert.DeserializeObject<HashSet<string>>(json); // Desserializa a blacklist
    }
}
  /*Black list FUNCTIONS*/


 /*Data functions*/
  List<DateTime> feriados = new List<DateTime>
{
    new DateTime(2024, 1, 1),  // Ano Novo
    new DateTime(2024, 2, 10), // Carnaval (sábado)
    new DateTime(2024, 2, 12), // Carnaval (segunda-feira)
    new DateTime(2024, 2, 13), // Carnaval (terça-feira)
    new DateTime(2024, 2, 14), // Quarta-feira de Cinzas (quarta-feira)
    new DateTime(2024, 3, 29), // Sexta-feira Santa
    new DateTime(2024, 3, 31), // Páscoa (domingo)
    new DateTime(2024, 4, 21), // Tiradentes
    new DateTime(2024, 5, 1),  // Dia do Trabalho
    new DateTime(2024, 5, 30), // Corpus Christi
    new DateTime(2024, 9, 7),  // Independência do Brasil
    new DateTime(2024, 10, 12),// Nossa Senhora Aparecida / Dia das Crianças
    new DateTime(2024, 11, 2), // Finados
    new DateTime(2024, 11, 15),// Proclamação da República
    new DateTime(2024, 12, 25) // Natal
};
  
  public int GetDiasUteis(DateTime startDate, DateTime endDate, List<DateTime> feriados)
{
    int diasUteis = 0;

    for (var date = startDate; date <= endDate; date = date.AddDays(1))
    {
        // Ignora finais de semana (sábado e domingo)
        if (date.DayOfWeek != DayOfWeek.Saturday && date.DayOfWeek != DayOfWeek.Sunday)
        {
            // Ignora feriados
            if (!feriados.Contains(date))
            {
                diasUteis++;
            }
        }
    }

    return diasUteis;
}

  private string GetColorClass(string dataUltimoMovimento)
{
    if (DateTime.TryParse(dataUltimoMovimento, out var lastMoveDate))
    {
        // Data atual
        var dataAtual = DateTime.Now;
        
        // Expectativa de movimentação
        var expectativaMovimentacao = Config.ConfigExpectativaMovimentacao ?? 0;

        // Lista de feriados 2024
        List<DateTime> feriados = new List<DateTime>
        {
            new DateTime(2024, 1, 1), new DateTime(2024, 2, 12), new DateTime(2024, 2, 13), 
            new DateTime(2024, 2, 14), new DateTime(2024, 3, 29), new DateTime(2024, 4, 21), 
            new DateTime(2024, 5, 1), new DateTime(2024, 5, 30), new DateTime(2024, 9, 7), 
            new DateTime(2024, 10, 12), new DateTime(2024, 11, 2), new DateTime(2024, 11, 15), 
            new DateTime(2024, 12, 25)
        };

        // Calcula a diferença em dias úteis
        var diasUteis = GetDiasUteis(lastMoveDate, dataAtual, feriados);

        // Verifica se a diferença está dentro da expectativa
        if (diasUteis <= expectativaMovimentacao)
        {
            return Config.ColorVerde; // Dentro do prazo, retorna verde
        }
        else
        {
            // Diferença acima da expectativa, inicia o cálculo
            var sobra = diasUteis - expectativaMovimentacao;

            if (sobra > 0)
            {
                // Subtrai a configuração amarelo
                sobra -= Config.ConfigAmarelo ?? 0;

                if (sobra > 0)
                {
                    // Subtrai a configuração vermelho
                    sobra -= Config.ConfigVermelho ?? 0;

                    if (sobra > 0)
                    {
                        return Config.ColorPreto; // Retorna preto se ainda sobrar
                    }

                    return Config.ColorVermelho; // Retorna vermelho se sobrar
                }

                return Config.ColorAmarelo; // Retorna amarelo se sobrar
            }
        }
    }

    return string.Empty; // Retorna vazio se a data não for válida
}

  protected override async Task OnInitializedAsync()
  {
      await LoadBlacklistFromLocalStorage();
      
      await LoadAdoptedProtocolsFromLocalStorage();
  }
 /*Data functions*/
}

}
