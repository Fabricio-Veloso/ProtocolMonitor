@using MyBlazorPwa
@inject IJSRuntime JSRuntime
@using MudBlazor
@inject ISnackbar Snackbar



    
  
  
    
  
    
    
  <div class="miniprotocol-grid">
    
    <div>
        <MudChipSet T="string" Class="mud-typography" CheckMark SelectionMode="SelectionMode.ToggleSelection">
            @foreach (var phase in phases)
            {
                var displayPhase = phase.Replace("PROCESSO DE AQUISIÇÕES DE BENS E SERVIÇOS - PABS - CREA-PE - 0", "").Trim();
                <MudChip Variant="Variant.Filled" 
                        OnClick="@(() => SetActivePhase(phase))" 
                        Style="@GetPhaseColor(displayPhase)" 
                        Color="Color.Warning" 
                        Value="@phase">
                    @displayPhase     
                </MudChip>
            }

                <MudChip Variant="Variant.Filled" 
                    OnClick="() => FilterByDate()" 
                    Style="@GetActiveButtonStyle(FilterByDateValue)" 
                    Color="Color.Dark" 
                    Value="@FilterByDateValue">
                <MudIcon Icon="@Icons.Material.Filled.CalendarMonth" />
                Por Data
                </MudChip>

                <MudChip Variant="Variant.Filled" 
                        OnClick="() => ShowAdoptedProtocols()" 
                        Style="@GetActiveButtonStyle(ShowAdoptedValue)" 
                        Color="Color.Dark" 
                        Value="@ShowAdoptedValue">
                    <MudIcon Icon="@Icons.Material.Filled.Bookmark" />
                    Marcados por você
                </MudChip>

                <MudChip Variant="Variant.Filled" 
                        OnClick="() => ShowAllProtocols()" 
                        Style="@GetActiveButtonStyle(ShowAllValue)" 
                        Color="Color.Dark" 
                        Value="@ShowAllValue">
                    <MudIcon Icon="@Icons.Material.Filled.List" />
                    Todos 
                </MudChip>

        </MudChipSet>
        <form id="textForm" style="margin-bottom: 20px" wi>
        <input type="text" id="userInput" @bind="searchTerm" @oninput="FilterByText" name="userInput" placeholder="Pesquisar" class="input-field">
      </form>
    </div>

    
      
    
    
    @if (filteredBySearch != null && filteredBySearch.Any())
  {
      foreach (var protocol in filteredBySearch)
      {
          <MudCard class="protocol-card" Outlined="true" @onclick="() => ShowProtocolModal(protocol)" Style="@GetColorClass(protocol.GetDataUltimoMovimento())">
            <MudCardContent>
                <MudText Class="lowercase-text">@TruncateDescription(protocol.Header.Descricao)</MudText>
            </MudCardContent>
          </MudCard>
      }
  }
  
    @if (currentFilter == FilterMode.ByDate && filteredByDate != null && filteredByDate.Any())
    {
        @foreach (var protocol in filteredByDate)
        {
          <MudCard class="protocol-card" Outlined="true" @onclick="() => ShowProtocolModal(protocol)" Style="@GetColorClass(protocol.GetDataUltimoMovimento())">
                <div>
                <MudChip T="string" Variant="Variant.Filled"  Size="Size.Small"
                   Style="@GetPhaseColor(protocol.Header.Assunto)">
                </MudChip>
                
                <MudCardContent Style=" padding: 1px;">
                
                    <MudText Class="lowercase-text">@TruncateDescription(protocol.Header.Descricao)</MudText> 
                </MudCardContent>
                </div>
            </MudCard>
        }
    }
    
    @if (currentFilter == FilterMode.ByPhase && (protocolsWithResponsable?.Any() == true || protocolsWithoutResponsable?.Any() == true))
    {
      @if(activePhase == "05 - EXECUÇÃO" ){
        
        @if (groupedProtocols != null && groupedProtocols.Any())
        {
            foreach (var group in groupedProtocols)
            {
                <div class="responsavel-group">
                    <div class=".responsavel-group h3">
                      <h3>@GetFirstTwoWords(group.Key)</h3>
          
                    @if (group.Any())
                    {
                        foreach (var protocol in group)
                        {
                          <MudCard class="protocol-card" Outlined="true" @onclick="() => ShowProtocolModal(protocol)" Style="@($"background-color:{MudBlazor.Colors.Gray.Darken1}; color:white;")">>
                              <MudCardContent>
                                  <MudText Class="lowercase-text">@TruncateDescription(protocol.Header.Descricao)</MudText>
                              </MudCardContent>
                          </MudCard>
                        }
                    }
                    else
                    {
                      <p>Sem protocolos disponíveis para este responsável.</p>
                    }
                </div>
              </div>
            }
        }
       
        @if (protocolsWithoutResponsable != null && protocolsWithoutResponsable.Any())
        {
            <div class="sem-responsavel-group">
                @foreach (var protocol in protocolsWithoutResponsable)
                {
                    <MudCard class="protocol-card" Outlined="true" @onclick="() => ShowProtocolModal(protocol)" Style="@($"background-color:{MudBlazor.Colors.Gray.Darken1}; color:white;")">
                          <MudCardContent>
                              <MudText Class="lowercase-text">@TruncateDescription(protocol.Header.Descricao)</MudText>
                          </MudCardContent>
                      </MudCard>
                }
            </div>
        }
      
      }
      
      @if(activePhase == "06 - ADITIVO DE CONTRATO" ){
        
        @if (groupedProtocols != null && groupedProtocols.Any())
        {
            foreach (var group in groupedProtocols)
            {
                <div class="responsavel-group">
                    <div class=".responsavel-group h3">
                      <h3>@GetFirstTwoWords(group.Key)</h3>
          
                    @if (group.Any())
                    {
                        foreach (var protocol in group)
                        {
                          <MudCard class="protocol-card" Outlined="true" @onclick="() => ShowProtocolModal(protocol)" Style="@($"background-color:{MudBlazor.Colors.Green.Darken1};")">
                              <MudCardContent>
                                  <MudText Class="lowercase-text">@TruncateDescription(protocol.Header.Descricao)</MudText>
                              </MudCardContent>
                          </MudCard>
                        }
                    }
                    else
                    {
                      <p>Sem protocolos disponíveis para este responsável.</p>
                    }
                </div>
              </div>
            }
        }
       
        @if (protocolsWithoutResponsable != null && protocolsWithoutResponsable.Any())
        {
            <div class="sem-responsavel-group">
                @foreach (var protocol in protocolsWithoutResponsable)
                {
                    <MudCard class="protocol-card" Outlined="true" @onclick="() => ShowProtocolModal(protocol)" Style="@($"background-color:{MudBlazor.Colors.Green.Darken1};")">
                          <MudCardContent>
                              <MudText Class="lowercase-text">@TruncateDescription(protocol.Header.Descricao)</MudText>
                          </MudCardContent>
                      </MudCard>
                }
            </div>
        }
      
      } 
      
       @if(activePhase != "06 - ADITIVO DE CONTRATO" && activePhase != "05 - EXECUÇÃO" ){
          @if (groupedProtocols != null && groupedProtocols.Any())
            {
                foreach (var group in groupedProtocols)
                {
                    <div class="responsavel-group">
                        <div class=".responsavel-group h3">
                          <h3>@GetFirstTwoWords(group.Key)</h3>
              
                        @if (group.Any())
                        {
                            foreach (var protocol in group)
                            {
                              <MudCard class="protocol-card" Outlined="true" @onclick="() => ShowProtocolModal(protocol)" Style="@GetColorClass(protocol.GetDataUltimoMovimento())">
                                  <MudCardContent>
                                      <MudText Class="lowercase-text">@TruncateDescription(protocol.Header.Descricao)</MudText>
                                  </MudCardContent>
                              </MudCard>
                            }
                        }
                        else
                        {
                          <p>Sem protocolos disponíveis para este responsável.</p>
                        }
                    </div>
                  </div>
                }
            }
           
            @if (protocolsWithoutResponsable != null && protocolsWithoutResponsable.Any())
            {
                <div class="sem-responsavel-group">
                    @foreach (var protocol in protocolsWithoutResponsable)
                    {
                        <MudCard class="protocol-card" Outlined="true" @onclick="() => ShowProtocolModal(protocol)" Style="@GetColorClass(protocol.GetDataUltimoMovimento())">
                              <MudCardContent>
                                  <MudText Class="lowercase-text">@TruncateDescription(protocol.Header.Descricao)</MudText>
                              </MudCardContent>
                          </MudCard>
                    }
                </div>
            }
      
      
      
      }
     
     
  }
  
    @if (currentFilter == FilterMode.Adopted && adoptedProtocols != null && adoptedProtocols.Any())
    {
        foreach (var protocol in adoptedProtocols)
        {
            <MudCard class="protocol-card" Outlined="true" @onclick="() => ShowProtocolModal(protocol)" Style="@GetColorClass(protocol.GetDataUltimoMovimento())">
        <MudCardContent>
            <MudText Class="lowercase-text">@TruncateDescription(protocol.Header.Descricao)</MudText>
        </MudCardContent>
    </MudCard>
        }
    }
   
    @if( currentFilter == FilterMode.None && protocolsList != null && protocolsList.Any())
    {
        
           <MudPaper Height="100%" Width="100%" Style="background-color: transparent; border: none;">
                
                <MudButton OnClick="OpenModal" Variant="Variant.Filled" Color="Color.Primary" StartIcon="@Icons.Material.Filled.BarChart">                
                Geral
                </MudButton>
            </MudPaper>
        
        <div>
        @foreach (var protocol in protocolsList)
        {
          
            <MudCard class="protocol-card" Outlined="true" @onclick="() => ShowProtocolModal(protocol)" Style="@GetColorClass(protocol.GetDataUltimoMovimento())">
                <div>
                <MudChip T="string" Variant="Variant.Filled"  Size="Size.Small"
                   Style="@GetPhaseColor(protocol.Header.Assunto)">
                </MudChip>
                
                <MudCardContent Style=" padding: 1px;">
                
                    <MudText Class="lowercase-text">@TruncateDescription(protocol.Header.Descricao)</MudText> 
                </MudCardContent>
                
                </div>
            </MudCard>
          
        }
        </div>
    }   
    
    @if (miniProtocolsList != null && miniProtocolsList.Any() && currentFilter == FilterMode.None)
  {
      foreach (var miniProtocol in miniProtocolsList.Where(p => !IsInBlacklist(p.Numero)))
      {
          <div class="miniprotocol-card @(GetColorClass(miniProtocol.DataUltimoMovimento))"
               title="Descrição: @miniProtocol.Descricao | Atualmente em: @miniProtocol.LocalizacaoAtual"
               @onclick="() => ShowMiniProtocolModal(miniProtocol)">
              <div class="content">
                  <div class="loader"></div>
                  <p class="description">@TruncateDescription(miniProtocol.Descricao)</p>
              </div>
          </div>
      }
  }
  
    <!-- Modal do protocolo completo -->
    @if (isProtocolModalVisible && selectedProtocol != null)
    {
        <div class="modal">
            <div class="modal-content">
              <span class="close-button" @onclick="HideProtocolModal">&times;</span>
              <MudPaper Class="pa-4" Elevation="1">
                <MudText Typo="Typo.h5" Align="Align.Center" Color="Color.Primary">Protocolo: @selectedProtocol.Header?.Numero</MudText>
                <MudDivider />

                  <MudGrid>
                      <MudItem xs="12" sm="6">
                          <MudText Typo="Typo.body1"><strong>Interessado:</strong> @selectedProtocol.Header?.Interessado</MudText>
                      </MudItem>
                      <MudItem xs="12" sm="6">
                          <MudText Typo="Typo.body1"><strong>Solicitante:</strong> @selectedProtocol.Header?.Solicitante</MudText>
                      </MudItem>
                      <MudItem xs="12" sm="6">
                          <MudText Typo="Typo.body1"><strong>Inspetoria:</strong> @selectedProtocol.Header?.Inspetoria</MudText>
                      </MudItem>
                      <MudItem xs="12" sm="6">
                          <MudText Typo="Typo.body1"><strong>Assunto:</strong> @selectedProtocol.Header?.Assunto</MudText>
                      </MudItem>
                      <MudItem xs="12" sm="6">
                          <MudText Typo="Typo.body1"><strong>Origem:</strong> @selectedProtocol.Header?.Origem</MudText>
                      </MudItem>
                      <MudItem xs="12" sm="6">
                          <MudText Typo="Typo.body1"><strong>Situação:</strong> @selectedProtocol.Header?.Situacao</MudText>
                      </MudItem>
                      <MudItem xs="12" sm="6">
                          <MudText Typo="Typo.body1"><strong>Destino:</strong> @selectedProtocol.Header?.Destino</MudText>
                      </MudItem>
                      <MudItem xs="12" sm="6">
                          <MudText Typo="Typo.body1"><strong>Sigiloso:</strong> @selectedProtocol.Header?.Sigiloso</MudText>
                      </MudItem>
                      <MudItem xs="12" sm="6">
                          <MudText Typo="Typo.body1"><strong>Data de Emissão:</strong> @selectedProtocol.Header?.DataEmissao</MudText>
                      </MudItem>
                      <MudItem xs="12">
                          <MudText Typo="Typo.body1"><strong>Descrição:</strong> @selectedProtocol.Header?.Descricao</MudText>
                      </MudItem>
                  </MudGrid>
              </MudPaper>
                    <div>
                      <button class="button"  @onclick="() => AddToBlacklist(selectedProtocol.Header.Numero)">Remover Da visualisação</button>
                      @if (IsAdopted(selectedProtocol.Header.Numero))
                      {
                          <button class="button" @onclick="() => RemoveFromAdoptedProtocols(selectedProtocol.Header.Numero)">Desmarcar</button>
                      }
                      else
                      {
                          <button class="button" @onclick="() => AddToAdoptedProtocols(selectedProtocol.Header.Numero)">Marcar Para Mim</button>
                      }
                    </div>
                    
    @if (selectedProtocol.Moves != null && selectedProtocol.Moves.Any())
    {
        
        bool isLeft = true;  // Usado para alternar entre esquerda e direita
    
        <MudTimeline style="padding: 20px;">
            @foreach (var move in selectedProtocol.Moves.AsEnumerable().Reverse())
            {
                <MudTimelineItem Color="Color.Info" Size="Size.Small">
                    <ItemOpposite>
                        @if (DateTime.TryParse(move.Data, out var dateValue))
                        {
                            @if (DateTime.TryParse(move.Hora, out var timeValue))
                            {
                                <MudText Typo="Typo.h6" class="@((isLeft) ? "timeline-item-left" : "")">
                                    @dateValue.ToShortDateString() - @timeValue.ToString("HH:mm")
                                </MudText>
                            }
                            else
                            {
                                <MudText Typo="Typo.h6" class="@((isLeft) ? "timeline-item-left" : "")">
                                    @dateValue.ToShortDateString() - Hora inválida
                                </MudText>
                            }
                        }
                        else
                        {
                            <MudText Typo="Typo.h6" class="@((isLeft) ? "timeline-item-left" : "")">
                                Data inválida
                            </MudText>
                        }
                    </ItemOpposite>
                    <ItemContent >
                        <MudText Typo="Typo.h6" GutterBottom="true"><b>Passo:</b> @move.Passo</MudText>
                        <MudText><strong>Usuário de Origem:</strong> @move.UsuarioOrigem</MudText>
                        <MudText><strong>Usuário de Destino:</strong> @move.UsuarioDestino</MudText>
                        <MudText><strong>Setor de Origem:</strong> @move.SetorOrigem</MudText>
                        <MudText><strong>Setor de Destino:</strong> @move.SetorDestino</MudText>
                        <MudDivider />
        
                        <MudChip Variant="Variant.Filled" Color="Color.Info" T="string">
                            @move.Descricao
                        </MudChip>
                        
                    </ItemContent>
                </MudTimelineItem>
    
                @* Alterna entre esquerda e direita *@
                isLeft = !isLeft;
            }
        </MudTimeline>
    }
    else
    {
        <p>Nenhuma movimentação encontrada.</p>
    }




            </div>
        </div>
    }
  
    @if (isMiniProtocolModalVisible && selectedMiniProtocol != null)
      {
          <div class="modal">
              <div class="modal-content">
                  <span class="close-button" @onclick="HideMiniProtocolModal">&times;</span>
                  <h3>@selectedMiniProtocol.Assunto</h3>
                  <p><strong>Número:</strong> @selectedMiniProtocol.Numero</p>
                  <p><strong>Descrição:</strong> @selectedMiniProtocol.Descricao</p>
                  <p><strong>Localização Atual:</strong> @selectedMiniProtocol.LocalizacaoAtual</p>
                  <p><strong>Último Movimento:</strong> @selectedMiniProtocol.DataUltimoMovimento @selectedMiniProtocol.HoraUltimoMovimento</p>
                  <button class="button" @onclick="() => AddToBlacklist(selectedMiniProtocol.Numero)">Não tenho interesse</button>
              </div>
          </div>
      }
 
    @if(ischartModalVisible == true){
      <div class="modal">
        <div class="modal-content">
      
          <MudPaper Class="pa-16 ma-2" Elevation="3">
             <MudChart ChartType="ChartType.Bar" 
                  ChartSeries="@Series" 
                  XAxisLabels="@setores.ToArray()" 
                  Width="100%" 
                  Height="350px"
                  SelectedIndexChanged="@OnSelectedIndexChanged">
                    <CustomGraphics>
                        <style>
                            .heavy { font: bold 20px Helvetica; }
                            .Rrrrr { font: italic 20px Helvetica; fill: rgb(0, 38, 255); }
                            .black{font: italic 20px Helvetica; fill: rgb(4, 0, 56);}
                        </style>
                        <text x=50% y=13% class="heavy">@SelectedSetor</text>
                        <text x=50% y=21% class="Rrrrr"> Média do setor: @((int)SelectedMediaHoras)</text>
                        <text x=50% y=30% class="Rrrrr"> Média Geral @((int)mediaGeral)</text>
                        <text x=4% y=68% class="black"> ---------------------------------------------------------------------------------------</text>

                    </CustomGraphics>
              </MudChart>
                  
        
          </MudPaper>
         
          
          <MudPaper Class="pa-4 mt-2 d-flex justify-center">
            <MudButton OnClick="CloseModal" Color="Color.Secondary">Fechar</MudButton>
          </MudPaper>
          
        </div>
      </div>
    }
    
  
  
</div>


@code {
    [Parameter]
    public List<MiniProtocolData> miniProtocolsList { get; set; } = new List<MiniProtocolData>();

    [Parameter]
    public List<ProtocolData> protocolsList { get; set; } = new List<ProtocolData>();

    [Parameter]
    public ByTimeColorConfig Config { get; set; }
    
    [Parameter]
    public string sector { get; set; }
    
    

    /*MODAL VARIABLES*/
    private bool isProtocolModalVisible = false;
    private bool isMiniProtocolModalVisible = false;
    private MiniProtocolData? selectedMiniProtocol = null;
    private ProtocolData? selectedProtocol = null;
    /*MODAL VARIABLES*/
    // Lista negra para armazenar números de protocolos apagados
    private HashSet<string> blacklist = new HashSet<string>();
    
    
    
    /*GRAFIC VARIABLES AND FUNCTIONS*/
    private List<string> setores = new List<string>();
    private double[] mediasHoras = new double[0];
    private bool ischartModalVisible = false;
    private int selectedIndex = -1;
    private double mediaGeral;

      // Variáveis para mostrar o setor selecionado e sua média de horas
    private string SelectedSetor = string.Empty;
    private double SelectedMediaHoras = 0;

    // Lista que contém os dados do gráfico
    public List<ChartSeries> Series { get; set; } = new List<ChartSeries>();
    

    // Função para abrir o modal e preparar os dados do gráfico
   async Task  OpenModal()
    {
        
        Console.WriteLine("Preparando dados do gráfico");
        await PrepareChartData(protocolsList); // Prepara os dados
        Console.WriteLine("Dados do gráfico preparados");
        await CalcularMediaGeral(protocolsList);
        ischartModalVisible = true;
        Console.WriteLine(ischartModalVisible);
        SetChartSeries();
        
        
    }
    
    async Task CalcularMediaGeral(List<ProtocolData> protocolos)
    {
        double totalHoras = 0;
        int totalProtocolos = 0;
    
        foreach (var protocolo in protocolos)
        {
            var movimentos = protocolo.Moves;
    
            for (int i = 1; i < movimentos.Count; i++) // Começa do segundo movimento
            {
                var movimentoAnterior = movimentos[i - 1];
                var movimentoAtual = movimentos[i];
    
                if (!string.IsNullOrEmpty(movimentoAnterior.Data) && !string.IsNullOrEmpty(movimentoAtual.Data))
                {
                    DateTime dataAnterior = DateTime.Parse(movimentoAnterior.Data);
                    DateTime dataAtual = DateTime.Parse(movimentoAtual.Data);
    
                    TimeSpan diff = dataAtual - dataAnterior;
    
                    totalHoras += diff.TotalHours; // Soma as horas totais
                    totalProtocolos++; // Conta o número total de protocolos
                }
            }
        }
    
        mediaGeral = totalProtocolos > 0 ? totalHoras / totalProtocolos : 0; // Retorna a média geral
    }

    
     private void SetChartSeries()
    {
        Series.Clear();
        for (int i = 0; i < setores.Count; i++)
        {
            Series.Add(new ChartSeries
            {
                Name = setores[i],
                Data = new double[] { mediasHoras[i] }
            });
        }
    }

    // Função para fechar o modal
    void CloseModal()
    {
        ischartModalVisible = false;
        
    }

    // Função que prepara os dados para o gráfico
    async Task PrepareChartData(List<ProtocolData> protocolos)
    {
        var mediaHorasPorSetor = CalcularMediaHorasPorSetor(protocolos);

        // Ordena os setores e as médias de horas de forma decrescente
        var orderedData = mediaHorasPorSetor
            .OrderByDescending(kvp => kvp.Value)
            .ToList();

        setores = orderedData
            .Select(kvp => kvp.Key.Replace("Recife/Sede - ", string.Empty))
            .ToList();

        mediasHoras = orderedData
            .Select(kvp => kvp.Value)
            .ToArray();
        
        // Prepara os dados para o gráfico
        Series = new List<ChartSeries>
        {
            new ChartSeries
            {
                Name = "Média de Horas",
                Data = mediasHoras
            }
        };
    }
    
    void OnSelectedIndexChanged(int index)
    {
        if (index >= 0 && index < setores.Count)
        {
            SelectedSetor = setores[index];
            SelectedMediaHoras = mediasHoras[index];
        }
    }
    
    public Dictionary<string, double> CalcularMediaHorasPorSetor(List<ProtocolData> protocolos)
    {
        var setorTimeData = new Dictionary<string, SectorTimeData>();

        foreach (var protocolo in protocolos)
        {
            var movimentos = protocolo.Moves;

            for (int i = 1; i < movimentos.Count; i++) // Começa do segundo movimento
            {
                var movimentoAnterior = movimentos[i - 1];
                var movimentoAtual = movimentos[i];

                if (!string.IsNullOrEmpty(movimentoAnterior.Data) && !string.IsNullOrEmpty(movimentoAtual.Data))
                {
                    DateTime dataAnterior = DateTime.Parse(movimentoAnterior.Data);
                    DateTime dataAtual = DateTime.Parse(movimentoAtual.Data);

                    TimeSpan diff = dataAtual - dataAnterior;
                    string setor = movimentoAnterior.SetorDestino ?? "Sem setor";

                    if (!setorTimeData.ContainsKey(setor))
                    {
                        setorTimeData[setor] = new SectorTimeData { Setor = setor, TotalHours = 0, Occurrences = 0 };
                    }

                    setorTimeData[setor].TotalHours += diff.TotalHours;
                    setorTimeData[setor].Occurrences++;
                }
            }
        }

        // Retorna a média de horas por setor
        return setorTimeData.ToDictionary(data => data.Key, data => data.Value.AverageHours());
    }
    
    
    // Classe ChartData para armazenar informações do gráfico
    public class ChartData
    {
        public string? Setor { get; set; }
        public double AverageHours { get; set; }
    }

    // A lista que contém os dados do gráfico
    private List<ChartData> chartData = new List<ChartData>();

    
    public class SectorTimeData
    {
        public string Setor { get; set; }
        public double TotalHours { get; set; }
        public int Occurrences { get; set; }

        public double AverageHours()
        {
            return Occurrences > 0 ? TotalHours / Occurrences : 0;
        }
    }
    
    /*GRAFIC VARIABLES AND FUNCTIONS*/
    
    /*FILTERS VARIABLES*/
    private const string FilterByDateValue = "Por Data";
    private const string ShowAdoptedValue = "Adotados";
    private const string ShowAllValue = "Todos";

    private DateTime? selectedDate; // Para filtro por data
    private string? selectedPhase; // Para filtro por fase
    private List<string> phases = new List<string>
    {
        "01 - SOLICITAÇÃO DE CONTRATAÇÃO",
        "02 - PLANEJAMENTO DE CONTRATAÇÃO",
        "03 - CONTRATAÇÃO DIRETA",
        "04 - LICITAÇÃO",
        "05 - EXECUÇÃO",
        "06 - ADITIVO DE CONTRATO"
    };
    private string activePhase = string.Empty;
    
    private enum FilterMode
    {
      None,
      ByDate,
      ByPhase,
      Adopted,
      ByTextSeach
    }

    private FilterMode currentFilter = FilterMode.None;
    private IEnumerable<ProtocolData>? filteredByDate;
    private Dictionary<string, IEnumerable<ProtocolData>> filteredByPhase = new Dictionary<string, IEnumerable<ProtocolData>>();
    private IEnumerable<ProtocolData>? adoptedProtocols;
    private HashSet<string> adoptedProtocolsList = new HashSet<string>();
    private string activeButton = string.Empty; 
    private string searchTerm = string.Empty; // Para armazenar o termo de busca
    private IEnumerable<IGrouping<string, ProtocolData>>? groupedProtocols; // Agrupado por responsável
    private IEnumerable<ProtocolData>? protocolsWithResponsable; // Protocolos com responsável
    private IEnumerable<ProtocolData>? protocolsWithoutResponsable; // Protocolos sem responsável
   
     /*FILTERS VARIABLES*/
    
    
    /*FILTERS FUNCTIONS*/
    
    private IEnumerable<ProtocolData>? filteredBySearch; // Para armazenar os protocolos filtrados por texto
    
    private void FilterByText(ChangeEventArgs e)
    {
        currentFilter = FilterMode.ByTextSeach;
        searchTerm = e.Value?.ToString() ?? string.Empty; // Atualiza o termo de busca
        
        if (!string.IsNullOrWhiteSpace(searchTerm))
        {
            filteredBySearch = protocolsList
                .Where(p => p.Header.Descricao != null && 
                            p.Header.Descricao.Contains(searchTerm, StringComparison.OrdinalIgnoreCase)) // Filtro por descrição
                .ToList();
        }
        else
        {
            filteredBySearch = null; // Mostra todos se o campo estiver vazio
        }
        
        StateHasChanged(); // Atualiza a interface para refletir o novo filtro
    }
    
    private async Task AddToAdoptedProtocols(string numero)
    {
        if (!adoptedProtocolsList.Contains(numero))
        {
            adoptedProtocolsList.Add(numero); // Adiciona o protocolo à lista
            await SaveAdoptedProtocolsToLocalStorage(); // Salva no LocalStorage
            Console.WriteLine($"Protocolo {numero} foi adotado com sucesso!");
            StateHasChanged();
        }
        else
        {
            Console.WriteLine($"Protocolo {numero} já foi adotado.");
        }
    }
    
    private async Task SaveAdoptedProtocolsToLocalStorage()
    {
        var json = JsonConvert.SerializeObject(adoptedProtocolsList); // Serializa a lista de adotados
        await JSRuntime.InvokeVoidAsync("localStorage.setItem", "adoptedProtocols", json); // Armazena no LocalStorage
    }
    
    private async Task RemoveFromAdoptedProtocols(string numero)
    {
      if (adoptedProtocolsList.Contains(numero))
      {
        adoptedProtocolsList.Remove(numero); // Remove o protocolo da lista
        await SaveAdoptedProtocolsToLocalStorage(); // Atualiza o LocalStorage
        Console.WriteLine($"Você retirou o protocolo de número {numero} de sua lista de responsabilidades");
        HideProtocolModal();
        ShowAdoptedProtocols();
        StateHasChanged();
      }
      else
      {
        Console.WriteLine($"Protocolo {numero} não está na lista de responsabilidade.");
      }
    }
    
    private async Task LoadAdoptedProtocolsFromLocalStorage()
    {
        var json = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "adoptedProtocols"); // Obtém o JSON do LocalStorage
        if (!string.IsNullOrEmpty(json))
        {
            adoptedProtocolsList = JsonConvert.DeserializeObject<HashSet<string>>(json); // Desserializa a lista de adotados
        }
    }
    
    private bool       IsAdopted(string numero)
    {
        return adoptedProtocolsList.Contains(numero);
    }
    
    private void       FilterByDate()
    {
        currentFilter = FilterMode.ByDate;
        filteredByDate = protocolsList
            .OrderBy(p => DateTime.Parse(p.GetDataUltimoMovimento()).Date)
            .ToList();
        activeButton = "ByDate"; // Atualiza o botão ativo
        StateHasChanged(); // Atualiza a interface
    }

    private void       SetActivePhase(string phase)
    {
        activePhase = phase; // Define a fase ativa
        FilterByPhase(phase); // Filtra pela fase selecionada
        activeButton = phase; // Atualiza o botão ativo
        StateHasChanged(); // Atualiza a interface
    }
    
    private void FilterByPhase(string selectedPhase)
    {
        currentFilter = FilterMode.ByPhase;
    
        var protocolsInPhase = protocolsList
            .Where(p => p.Header.Assunto == selectedPhase)
            .ToList();
    
        // Separar os protocolos com e sem responsável
        groupedProtocols = protocolsInPhase
            .Where(p => !string.IsNullOrEmpty(p.Responsavel) && p.Responsavel != "Sem responsavel")
            .GroupBy(p => p.Responsavel)
            .ToList();
    
        protocolsWithoutResponsable = protocolsInPhase
            .Where(p => string.IsNullOrEmpty(p.Responsavel) || p.Responsavel == "Sem responsavel")
            .ToList();
    
        StateHasChanged(); // Atualiza a interface
    }
    
    private string     GetActiveButtonStyle(string buttonName)
    {
        // Se o botão for o ativo, aplica o estilo extra
        if (activeButton == buttonName)
        {
            return "border: 3px solid #ff0000; transform: scale(1.1);"; // Borda vermelha e leve aumento de tamanho
        }
        return string.Empty; // Sem alteração para os botões inativos
    }
    
   private string GetPhaseColor(string displayPhase)
{
    return displayPhase switch
    {
        "01 - SOLICITAÇÃO DE CONTRATAÇÃO" => $"background-color:{Colors.Orange.Accent4};",
        "02 - PLANEJAMENTO DE CONTRATAÇÃO" => $"background-color:{Colors.Indigo.Default};",
        "03 - CONTRATAÇÃO DIRETA" => $"background-color:{Colors.Purple.Accent4};",
        "04 - LICITAÇÃO" => $"background-color:{Colors.Pink.Accent2};",
        "05 - EXECUÇÃO" => $"background-color:{Colors.Gray.Default};",
        "06 - ADITIVO DE CONTRATO" => $"background-color:{Colors.Green.Accent4};",
        _ => $"background-color:{Colors.Blue.Lighten3};"
    };
}

    
    private void       ShowAdoptedProtocols()
    {
        currentFilter = FilterMode.Adopted;
        adoptedProtocols = protocolsList
            .Where(p => adoptedProtocolsList.Contains(p.Header.Numero))
            .ToList();
        activeButton = "Adopted"; // Atualiza o botão ativo
        StateHasChanged(); // Atualiza a interface
    }
    
    private void       ShowAllProtocols()
    {
        currentFilter = FilterMode.None;
        filteredByDate = null;
        filteredByPhase.Clear();
        adoptedProtocols = null;
        activeButton = "All"; // Atualiza o botão ativo
        StateHasChanged(); // Atualiza a interface
    }
    
    public string      GetPhaseClass(string assunto)
    {
      if (phases.Contains(assunto))
      {
        return assunto switch
        {
          "01 - SOLICITAÇÃO DE CONTRATAÇÃO" => "phase-solicitacao",
          "02 - PLANEJAMENTO DE CONTRATAÇÃO" => "phase-planejamento",
          "03 - CONTRATAÇÃO DIRETA" => "phase-contratacao",
          "04 - LICITAÇÃO" => "phase-licitacao",
          "05 - EXECUÇÃO" => "phase-execucao",
          "06 - ADITIVO DE CONTRATO" => "phase-aditivo",
          _ => "phase-default"
        };
      }
      return "phase-default";
    }
  /*FILTERS FUNCTIONS*/
  
  private string GetFirstTwoWords(string input)
    {
        if (string.IsNullOrWhiteSpace(input))
            return string.Empty; // Retorna vazio se a entrada for nula ou vazia

        var words = input.Split(' '); // Divide a string em palavras
        return string.Join(" ", words.Take(2)); // Junta as duas primeiras palavras
    }
  
  private string TruncateDescription(string description)
    {
        if (description.Length > 60)
        {
            return description.Substring(0, 60) + "..."; // Limita a 40 caracteres e adiciona "..."
        }
        return description;
    }


  /*MODAL FUNCTIONS*/
  private void ShowProtocolModal(ProtocolData protocol)
    {
        selectedProtocol = protocol;
        isProtocolModalVisible = true;
        StateHasChanged(); 
    }

  private void HideProtocolModal()
    {
        isMiniProtocolModalVisible = false;
        selectedProtocol = null;
    }
    
  private void ShowMiniProtocolModal(MiniProtocolData miniProtocol)
    {
        selectedMiniProtocol = miniProtocol;
        isMiniProtocolModalVisible = true;
        StateHasChanged();
    }
    
  private void HideMiniProtocolModal()
    {
        isMiniProtocolModalVisible = false;
        selectedMiniProtocol = null;
    }
  /*MODAL FUNCTIONS*/
   
   
   /*Black list FUNCTIONS*/
  private async Task AddToBlacklist(string numero)
  {
    blacklist.Add(numero); // Adiciona o número à lista negra
    await SaveBlacklistToLocalStorage(); // Salva a blacklist no localStorage
    HideProtocolModal();
    HideMiniProtocolModal();// Oculta o modal após adicionar
    StateHasChanged(); // Atualiza a interface
  }

  private bool IsInBlacklist(string numero)
    {
        return blacklist.Contains(numero); // Verifica se o número está na lista negra
    }

  private async Task SaveBlacklistToLocalStorage()
{
  var json = JsonConvert.SerializeObject(blacklist); // Serializa a blacklist
  await JSRuntime.InvokeVoidAsync("localStorage.setItem", "blacklist", json); // Armazena no localStorage
}

  private async Task LoadBlacklistFromLocalStorage()
{
    var json = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "blacklist"); // Obtém o JSON do localStorage
    if (!string.IsNullOrEmpty(json))
    {
        blacklist = JsonConvert.DeserializeObject<HashSet<string>>(json); // Desserializa a blacklist
    }
}
  /*Black list FUNCTIONS*/


 /*Data functions*/
  List<DateTime> feriados = new List<DateTime>
{
    new DateTime(2024, 1, 1),  // Ano Novo
    new DateTime(2024, 2, 10), // Carnaval (sábado)
    new DateTime(2024, 2, 12), // Carnaval (segunda-feira)
    new DateTime(2024, 2, 13), // Carnaval (terça-feira)
    new DateTime(2024, 2, 14), // Quarta-feira de Cinzas (quarta-feira)
    new DateTime(2024, 3, 29), // Sexta-feira Santa
    new DateTime(2024, 3, 31), // Páscoa (domingo)
    new DateTime(2024, 4, 21), // Tiradentes
    new DateTime(2024, 5, 1),  // Dia do Trabalho
    new DateTime(2024, 5, 30), // Corpus Christi
    new DateTime(2024, 9, 7),  // Independência do Brasil
    new DateTime(2024, 10, 12),// Nossa Senhora Aparecida / Dia das Crianças
    new DateTime(2024, 11, 2), // Finados
    new DateTime(2024, 11, 15),// Proclamação da República
    new DateTime(2024, 12, 25) // Natal
};
  
  public int GetDiasUteis(DateTime startDate, DateTime endDate, List<DateTime> feriados)
{
    int diasUteis = 0;

    for (var date = startDate; date <= endDate; date = date.AddDays(1))
    {
        // Ignora finais de semana (sábado e domingo)
        if (date.DayOfWeek != DayOfWeek.Saturday && date.DayOfWeek != DayOfWeek.Sunday)
        {
            // Ignora feriados
            if (!feriados.Contains(date))
            {
                diasUteis++;
            }
        }
    }

    return diasUteis;
}

    private string GetColorClass(string dataUltimoMovimento)
    {
        if (DateTime.TryParse(dataUltimoMovimento, out var lastMoveDate))
        {
            // Data atual
            var dataAtual = DateTime.Now;
            
            // Expectativa de movimentação
            var expectativaMovimentacao = Config.ConfigExpectativaMovimentacao ?? 0;

            // Lista de feriados 2024
            List<DateTime> feriados = new List<DateTime>
            {
                new DateTime(2024, 1, 1), new DateTime(2024, 2, 12), new DateTime(2024, 2, 13), 
                new DateTime(2024, 2, 14), new DateTime(2024, 3, 29), new DateTime(2024, 4, 21), 
                new DateTime(2024, 5, 1), new DateTime(2024, 5, 30), new DateTime(2024, 9, 7), 
                new DateTime(2024, 10, 12), new DateTime(2024, 11, 2), new DateTime(2024, 11, 15), 
                new DateTime(2024, 12, 25)
            };

            // Calcula a diferença em dias úteis
            var diasUteis = GetDiasUteis(lastMoveDate, dataAtual, feriados);

            // Verifica se a diferença está dentro da expectativa
            if (diasUteis <= expectativaMovimentacao)
            {
                return $"background-color:{Config.ColorVerde};"; // Dentro do prazo, retorna verde
            }
            else
            {
                // Diferença acima da expectativa, inicia o cálculo
                var sobra = diasUteis - expectativaMovimentacao;

                if (sobra > 0)
                {
                    // Subtrai a configuração amarelo
                    sobra -= Config.ConfigAmarelo ?? 0;

                    if (sobra > 0)
                    {
                        // Subtrai a configuração vermelho
                        sobra -= Config.ConfigVermelho ?? 0;

                        if (sobra > 0)
                        {
                            return $"background-color:{Config.ColorPreto};color:white;"; // Retorna preto se ainda sobrar
                        }

                        return $"background-color:{Config.ColorVermelho};"; // Retorna vermelho se sobrar
                    }

                    return $"background-color:{Config.ColorAmarelo};"; // Retorna amarelo se sobrar
                }
            }
        }

        return string.Empty; // Retorna vazio se a data não for válida
    }
  
  protected override async Task OnInitializedAsync()
  {
      await LoadBlacklistFromLocalStorage();
      
      await LoadAdoptedProtocolsFromLocalStorage();
  }
 /*Data functions*/
}


