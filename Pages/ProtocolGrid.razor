@using MyBlazorPwa
@inject IJSRuntime JSRuntime

<div class="miniprotocol-grid">
  <div> 
    <button class="button" @onclick="() => FilterByDate()">Filtrar por Data</button>
    @foreach (var phase in phases)
    {
      var displayPhase = phase.Replace("PROCESSO DE AQUISIÇÕES DE BENS E SERVIÇOS - PABS - CREA-PE - 0", "").Trim();
      <button class="button" @onclick="() => FilterByPhase(phase)">Filtrar por @displayPhase</button>
    }

    <button class="button" @onclick="ShowAdoptedProtocols">Mostrar Protocolos sob sua responsabilidade</button>
    <button class="button" @onclick="ShowAllProtocols">Mostrar Todos os Protocolos</button>
  </div> 
  @if (currentFilter == FilterMode.ByDate && filteredByDate != null && filteredByDate.Any())
  {
      @foreach (var protocol in filteredByDate)
      {
          <div class="protocol-card @(GetColorClass(protocol.GetDataUltimoMovimento()))"
               title="Descrição: @protocol.Header.Descricao | Atualmente em: @protocol.GetSetorUltimoMovimento()"
               @onclick="() => ShowProtocolModal(protocol)">
               <div class="phase-label @(GetPhaseClass(protocol.Header.Assunto))"></div>
              <div class="content">
                  <p class="description">@TruncateDescription(protocol.Header.Descricao)</p>
              </div>
          </div>
      }
  }
  
  @if (currentFilter == FilterMode.ByPhase && filteredByPhase.Any())
  {
      foreach (var phase in filteredByPhase)
      {
          foreach (var protocol in phase.Value)
          {
              <div class="protocol-card @(GetColorClass(protocol.GetDataUltimoMovimento()))"
                   title="Descrição: @protocol.Header.Descricao | Atualmente em: @protocol.GetSetorUltimoMovimento()"
                   @onclick="() => ShowProtocolModal(protocol)">
                   <div class="phase-label @(GetPhaseClass(protocol.Header.Assunto))"></div>
                  <div class="content">
                      <p class="description">@TruncateDescription(protocol.Header.Descricao)</p>
                  </div>
              </div>
          }
      }
  }
 
  @if (currentFilter == FilterMode.Adopted && adoptedProtocols != null && adoptedProtocols.Any())
  {
      foreach (var protocol in adoptedProtocols)
      {
          <div class="protocol-card @(GetColorClass(protocol.GetDataUltimoMovimento()))"
               title="Descrição: @protocol.Header.Descricao | Atualmente em: @protocol.GetSetorUltimoMovimento()"
               @onclick="() => ShowProtocolModal(protocol)">
               <div class="phase-label @(GetPhaseClass(protocol.Header.Assunto))"></div>
              <div class="content">
                  <p class="description">@TruncateDescription(protocol.Header.Descricao)</p>
              </div>
          </div>
      }
  }
 
  @if( currentFilter == FilterMode.None && protocolsList != null && protocolsList.Any())
  {
    foreach (var protocol in protocolsList)
    {
      <div class="protocol-card @(GetColorClass(protocol.GetDataUltimoMovimento()))"
         title="Descrição: @protocol.Header.Descricao | Atualmente em: @protocol.GetSetorUltimoMovimento()"
         @onclick="() => ShowProtocolModal(protocol)">
         <div class="phase-label @(GetPhaseClass(protocol.Header.Assunto))"></div>
        <div class="content">
            <p class="description">@TruncateDescription(protocol.Header.Descricao)</p>
        </div>
      </div>
    }
  }
  
  @if (miniProtocolsList != null && miniProtocolsList.Any())
{
    foreach (var miniProtocol in miniProtocolsList.Where(p => !IsInBlacklist(p.Numero)))
    {
        <div class="miniprotocol-card @(GetColorClass(miniProtocol.DataUltimoMovimento))"
             title="Descrição: @miniProtocol.Descricao | Atualmente em: @miniProtocol.LocalizacaoAtual"
             @onclick="() => ShowMiniProtocolModal(miniProtocol)">
            <div class="content">
                <div class="loader"></div>
                <p class="description">@TruncateDescription(miniProtocol.Descricao)</p>
            </div>
        </div>
    }
}

  <!-- Modal do protocolo completo -->
  @if (isProtocolModalVisible && selectedProtocol != null)
  {
      <div class="modal">
          <div class="modal-content">
              <span class="close-button" @onclick="HideProtocolModal">&times;</span>
              <h3>Protocolo: @selectedProtocol.Header?.Numero</h3>
                  <p><strong>Interessado:</strong> @selectedProtocol.Header?.Interessado</p>
                  <p><strong>Solicitante:</strong> @selectedProtocol.Header?.Solicitante</p>
                  <p><strong>Inspetoria:</strong> @selectedProtocol.Header?.Inspetoria</p>
                  <p><strong>Assunto:</strong> @selectedProtocol.Header?.Assunto</p>
                  <p><strong>Origem:</strong> @selectedProtocol.Header?.Origem</p>
                  <p><strong>Situação:</strong> @selectedProtocol.Header?.Situacao</p>
                  <p><strong>Destino:</strong> @selectedProtocol.Header?.Destino</p>
                  <p><strong>Sigiloso:</strong> @selectedProtocol.Header?.Sigiloso?</p>
                  <p><strong>Data de Emissão:</strong> @selectedProtocol.Header?.DataEmissao?</p>
                  <p><strong>Descrição:</strong> @selectedProtocol.Header?.Descricao</p>
                  <div>
                    <button class="button"  @onclick="() => AddToBlacklist(selectedProtocol.Header.Numero)">Apagar protocolo</button>
                    @if (IsAdopted(selectedProtocol.Header.Numero))
                    {
                        <button class="button" @onclick="() => RemoveFromAdoptedProtocols(selectedProtocol.Header.Numero)">Retirar da lista de protocolos sob sua responsabilidade</button>
                    }
                    else
                    {
                        <button class="button" @onclick="() => AddToAdoptedProtocols(selectedProtocol.Header.Numero)">Adotar</button>
                    }
                  </div>
                  <h4>Movimentações:</h4>
                  @if (selectedProtocol.Moves != null && selectedProtocol.Moves.Any())
                  {
                      @foreach (var move in selectedProtocol.Moves)
                      {
                        <div class="move-container">
                            <div class="move-card">
                                <p><strong>Passo:</strong> @move.Passo</p>
                                <p><strong>Usuário de Origem:</strong> @move.UsuarioOrigem</p>
                                <p><strong>Usuário de Destino:</strong> @move.UsuarioDestino</p>
                                <p><strong>Setor de Origem:</strong> @move.SetorOrigem</p>
                                <p><strong>Setor de Destino:</strong> @move.SetorDestino</p>
                                <p><strong>Descrição:</strong> @move.Descricao</p>
                                <p><strong>Data:</strong> @move.Data?</p>
                                <p><strong>Hora:</strong> @move.Hora?</p>
                                <p><strong>Sigiloso:</strong> @move.Sigiloso?</p>
                            </div>
                            @if (move != selectedProtocol.Moves.Last())
                            {
                                <div class="move-separator"></div>
                            }
                        </div>
                      }
                  }
                  else
                  {
                      <p>Nenhuma movimentação encontrada.</p>
                  }
          </div>
      </div>
  }

  @if (isMiniProtocolModalVisible && selectedMiniProtocol != null)
    {
        <div class="modal">
            <div class="modal-content">
                <span class="close-button" @onclick="HideMiniProtocolModal">&times;</span>
                <h3>@selectedMiniProtocol.Assunto</h3>
                <p><strong>Número:</strong> @selectedMiniProtocol.Numero</p>
                <p><strong>Descrição:</strong> @selectedMiniProtocol.Descricao</p>
                <p><strong>Localização Atual:</strong> @selectedMiniProtocol.LocalizacaoAtual</p>
                <p><strong>Último Movimento:</strong> @selectedMiniProtocol.DataUltimoMovimento @selectedMiniProtocol.HoraUltimoMovimento</p>
                <button class="button" @onclick="() => AddToBlacklist(selectedMiniProtocol.Numero)">Não tenho interesse</button>
            </div>
        </div>
    }
    
</div>

@code {
    [Parameter]
    public List<MiniProtocolData> miniProtocolsList { get; set; } = new List<MiniProtocolData>();

    [Parameter]
    public List<ProtocolData> protocolsList { get; set; } = new List<ProtocolData>();

    [Parameter]
    public ByTimeColorConfig Config { get; set; }

    /*MODAL VARIABLES*/
    private bool isProtocolModalVisible = false;
    private bool isMiniProtocolModalVisible = false;
    private MiniProtocolData? selectedMiniProtocol = null;
    private ProtocolData? selectedProtocol = null;

    // Lista negra para armazenar números de protocolos
    private HashSet<string> blacklist = new HashSet<string>();

    /*FILTERS*/
    private DateTime? selectedDate; // Para filtro por data
    private string? selectedPhase; // Para filtro por fase
    private List<string> phases = new List<string>
    {
        "01 - SOLICITAÇÃO DE CONTRATAÇÃO",
        "02 - PLANEJAMENTO DE CONTRATAÇÃO",
        "03 - CONTRATAÇÃO DIRETA",
        "04 - LICITAÇÃO",
        "05 - EXECUÇÃO",
        "06 - ADITIVO DE CONTRATO"
    };

    private enum FilterMode
    {
      None,
      ByDate,
      ByPhase,
      Adopted
    }

    private FilterMode currentFilter = FilterMode.None;
    private IEnumerable<ProtocolData>? filteredByDate;
    private Dictionary<string, IEnumerable<ProtocolData>> filteredByPhase = new Dictionary<string, IEnumerable<ProtocolData>>();
    private IEnumerable<ProtocolData>? adoptedProtocols;
    private HashSet<string> adoptedProtocolsList = new HashSet<string>();

    private async Task AddToAdoptedProtocols(string numero)
    {
        if (!adoptedProtocolsList.Contains(numero))
        {
            adoptedProtocolsList.Add(numero); // Adiciona o protocolo à lista
            await SaveAdoptedProtocolsToLocalStorage(); // Salva no LocalStorage
            Console.WriteLine($"Protocolo {numero} foi adotado com sucesso!");
            StateHasChanged();
        }
        else
        {
            Console.WriteLine($"Protocolo {numero} já foi adotado.");
        }
    }
    
    private async Task SaveAdoptedProtocolsToLocalStorage()
    {
        var json = JsonConvert.SerializeObject(adoptedProtocolsList); // Serializa a lista de adotados
        await JSRuntime.InvokeVoidAsync("localStorage.setItem", "adoptedProtocols", json); // Armazena no LocalStorage
    }
    
    private async Task RemoveFromAdoptedProtocols(string numero)
    {
      if (adoptedProtocolsList.Contains(numero))
      {
        adoptedProtocolsList.Remove(numero); // Remove o protocolo da lista
        await SaveAdoptedProtocolsToLocalStorage(); // Atualiza o LocalStorage
        Console.WriteLine($"Você retirou o protocolo de número {numero} de sua lista de responsabilidades");
        HideProtocolModal();
        ShowAdoptedProtocols();
        StateHasChanged();
      }
      else
      {
        Console.WriteLine($"Protocolo {numero} não está na lista de responsabilidade.");
      }
    }
    
    private async Task LoadAdoptedProtocolsFromLocalStorage()
    {
        var json = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "adoptedProtocols"); // Obtém o JSON do LocalStorage
        if (!string.IsNullOrEmpty(json))
        {
            adoptedProtocolsList = JsonConvert.DeserializeObject<HashSet<string>>(json); // Desserializa a lista de adotados
        }
    }
    
    private bool IsAdopted(string numero)
    {
        return adoptedProtocolsList.Contains(numero);
    }
    
    private void FilterByDate()
    {
        currentFilter = FilterMode.ByDate;
        filteredByDate = protocolsList
            .OrderBy(p => DateTime.Parse(p.GetDataUltimoMovimento()).Date) // Ordena pela data do último movimento
            .ToList(); // Converte para uma lista se necessário
        StateHasChanged(); // Atualiza a interface
    }

    private void FilterByPhase(string selectedPhase)
    {
      currentFilter = FilterMode.ByPhase;
      
      filteredByPhase = protocolsList
          .Where(p => p.Header.Assunto == selectedPhase)
          .GroupBy(p => p.Header.Assunto ?? "Unknown") // Use "Unknown" ou outro valor padrão se Assunto for nulo
          .ToDictionary(g => g.Key!, g => g.AsEnumerable()); // Use o operador de não nulidade (!) para garantir que a chave não seja nula
      
      StateHasChanged();
    }

    private void ShowAdoptedProtocols()
    {
        currentFilter = FilterMode.Adopted;
    
        // Filtra os protocolos adotados usando a lista de números de protocolos adotados
        adoptedProtocols = protocolsList
            .Where(p => adoptedProtocolsList.Contains(p.Header.Numero))
            .ToList();
    
        // Atualiza a interface
        StateHasChanged();
    }

    private void ShowAllProtocols()
    {
        currentFilter = FilterMode.None;
        filteredByDate = null;
        filteredByPhase.Clear();
        adoptedProtocols = null;
        StateHasChanged();
    }
    
    public string GetPhaseClass(string assunto)
    {
      if (phases.Contains(assunto))
      {
        return assunto switch
        {
          "01 - SOLICITAÇÃO DE CONTRATAÇÃO" => "phase-solicitacao",
          "02 - PLANEJAMENTO DE CONTRATAÇÃO" => "phase-planejamento",
          "03 - CONTRATAÇÃO DIRETA" => "phase-contratacao",
          "04 - LICITAÇÃO" => "phase-licitacao",
          "05 - EXECUÇÃO" => "phase-execucao",
          "06 - ADITIVO DE CONTRATO" => "phase-aditivo",
          _ => "phase-default"
        };
      }
      return "phase-default";
    }
  /*FILTERS*/
  private string TruncateDescription(string description)
    {
        if (description.Length > 40)
        {
            return description.Substring(0, 40) + "..."; // Limita a 40 caracteres e adiciona "..."
        }
        return description;
    }

  protected override async Task OnInitializedAsync()
  {
      await LoadBlacklistFromLocalStorage();
      
      await LoadAdoptedProtocolsFromLocalStorage();
  }

  private void ShowProtocolModal(ProtocolData protocol)
    {
        selectedProtocol = protocol;
        isProtocolModalVisible = true;
        StateHasChanged(); 
    }

  private void HideProtocolModal()
    {
        isMiniProtocolModalVisible = false;
        selectedProtocol = null;
    }
    
  private void ShowMiniProtocolModal(MiniProtocolData miniProtocol)
    {
        selectedMiniProtocol = miniProtocol;
        isMiniProtocolModalVisible = true;
        StateHasChanged();
    }
    
  private void HideMiniProtocolModal()
    {
        isMiniProtocolModalVisible = false;
        selectedMiniProtocol = null;
    }
   
  private async Task AddToBlacklist(string numero)
  {
    blacklist.Add(numero); // Adiciona o número à lista negra
    await SaveBlacklistToLocalStorage(); // Salva a blacklist no localStorage
    HideProtocolModal();
    HideMiniProtocolModal();// Oculta o modal após adicionar
    StateHasChanged(); // Atualiza a interface
  }

  private bool IsInBlacklist(string numero)
    {
        return blacklist.Contains(numero); // Verifica se o número está na lista negra
    }

  private async Task SaveBlacklistToLocalStorage()
{
  var json = JsonConvert.SerializeObject(blacklist); // Serializa a blacklist
  await JSRuntime.InvokeVoidAsync("localStorage.setItem", "blacklist", json); // Armazena no localStorage
}

  private async Task LoadBlacklistFromLocalStorage()
{
    var json = await JSRuntime.InvokeAsync<string>("localStorage.getItem", "blacklist"); // Obtém o JSON do localStorage
    if (!string.IsNullOrEmpty(json))
    {
        blacklist = JsonConvert.DeserializeObject<HashSet<string>>(json); // Desserializa a blacklist
    }
}

  List<DateTime> feriados = new List<DateTime>
{
    new DateTime(2024, 1, 1),  // Ano Novo
    new DateTime(2024, 2, 10), // Carnaval (sábado)
    new DateTime(2024, 2, 12), // Carnaval (segunda-feira)
    new DateTime(2024, 2, 13), // Carnaval (terça-feira)
    new DateTime(2024, 2, 14), // Quarta-feira de Cinzas (quarta-feira)
    new DateTime(2024, 3, 29), // Sexta-feira Santa
    new DateTime(2024, 3, 31), // Páscoa (domingo)
    new DateTime(2024, 4, 21), // Tiradentes
    new DateTime(2024, 5, 1),  // Dia do Trabalho
    new DateTime(2024, 5, 30), // Corpus Christi
    new DateTime(2024, 9, 7),  // Independência do Brasil
    new DateTime(2024, 10, 12),// Nossa Senhora Aparecida / Dia das Crianças
    new DateTime(2024, 11, 2), // Finados
    new DateTime(2024, 11, 15),// Proclamação da República
    new DateTime(2024, 12, 25) // Natal
};
  
  public int GetDiasUteis(DateTime startDate, DateTime endDate, List<DateTime> feriados)
{
    int diasUteis = 0;

    for (var date = startDate; date <= endDate; date = date.AddDays(1))
    {
        // Ignora finais de semana (sábado e domingo)
        if (date.DayOfWeek != DayOfWeek.Saturday && date.DayOfWeek != DayOfWeek.Sunday)
        {
            // Ignora feriados
            if (!feriados.Contains(date))
            {
                diasUteis++;
            }
        }
    }

    return diasUteis;
}

  private string GetColorClass(string dataUltimoMovimento)
{
    if (DateTime.TryParse(dataUltimoMovimento, out var lastMoveDate))
    {
        // Data atual
        var dataAtual = DateTime.Now;
        
        // Expectativa de movimentação
        var expectativaMovimentacao = Config.ConfigExpectativaMovimentacao ?? 0;

        // Lista de feriados 2024
        List<DateTime> feriados = new List<DateTime>
        {
            new DateTime(2024, 1, 1), new DateTime(2024, 2, 12), new DateTime(2024, 2, 13), 
            new DateTime(2024, 2, 14), new DateTime(2024, 3, 29), new DateTime(2024, 4, 21), 
            new DateTime(2024, 5, 1), new DateTime(2024, 5, 30), new DateTime(2024, 9, 7), 
            new DateTime(2024, 10, 12), new DateTime(2024, 11, 2), new DateTime(2024, 11, 15), 
            new DateTime(2024, 12, 25)
        };

        // Calcula a diferença em dias úteis
        var diasUteis = GetDiasUteis(lastMoveDate, dataAtual, feriados);

        // Verifica se a diferença está dentro da expectativa
        if (diasUteis <= expectativaMovimentacao)
        {
            return Config.ColorVerde; // Dentro do prazo, retorna verde
        }
        else
        {
            // Diferença acima da expectativa, inicia o cálculo
            var sobra = diasUteis - expectativaMovimentacao;

            if (sobra > 0)
            {
                // Subtrai a configuração amarelo
                sobra -= Config.ConfigAmarelo ?? 0;

                if (sobra > 0)
                {
                    // Subtrai a configuração vermelho
                    sobra -= Config.ConfigVermelho ?? 0;

                    if (sobra > 0)
                    {
                        return Config.ColorPreto; // Retorna preto se ainda sobrar
                    }

                    return Config.ColorVermelho; // Retorna vermelho se sobrar
                }

                return Config.ColorAmarelo; // Retorna amarelo se sobrar
            }
        }
    }

    return string.Empty; // Retorna vazio se a data não for válida
}
}


